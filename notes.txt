NOTES

	Initial Comments on the TryThree branch:
    // Trying not to repeat code:
    // alt1: report shadow members directly from findMember. but then, how should we do type comparison?
    // alt2: instead of shadow members, use shadow base types. Treat bases as intersected types.
    //    but how to express lack of mutability?--perhaps a type member in a refinement of the shadow base?
    // Again here we run into the problem of expressing a lack of mutability given an underlying
    // type that has mutability. This seems like a situation where we would want to do an override
    // if the underlying type already contains that type member. Overrides are OK--I think I can
    // live with overrides.

    /*
    ATTEMPT 1: FAILED: A RefinedType is not always accepted where a TermRef is accepted.
      One failure instance: in realApply in Applications: methPart(fun1).tpe is expected to be a TermRef.
        The problem here seems to be that the underlying type is a method rather than a reference,
        so one way to fix this is to check that we've actually got a reference type underlying.
      Update: as it turns out, just checking for a non-methodic type is not enough. Also, checking for a stable TermRef is not enough.
      An alternative is to do adaptations only on certain kinds of trees, but this could get ugly.

    val MutabilityMember = typeName("$$$$_mutability!$$$$")

    // For TermRefs: viewpoint-adapt the prefix.
    def adaptTermRef(tpe: TermRef)(implicit ctx: Context): Type = {
      val prefix = tpe.prefix
      prefix.findMember(MutabilityMember, prefix.widenIfUnstable, EmptyFlags) match {
        case NoDenotation => RefinedType(tpe, MutabilityMember, defn.NothingType)
        case denot: SingleDenotation => RefinedType(tpe, MutabilityMember, denot.info)
      }
    }

    // For ThisTypes: viewpoint-adapt based on enclosing-scope annotations.
    def adaptThisType(tpe: ThisType): Type = {
      tpe
    }

    def adaptAnnotatedType(tpe: AnnotatedType)(implicit ctx: Context): Type = {
      if (tpe.annot.symbol eq defn.ReadonlyAnnot)
        RefinedType(tpe.underlying, MutabilityMember, TypeBounds(defn.NothingType, defn.AnyType))
      else
        tpe.derivedAnnotatedType(adaptType(tpe), tpe.annot)
    }

    def adaptType(tpe: Type)(implicit ctx: Context): Type = tpe match {
      case tpe: AnnotatedType => adaptAnnotatedType(tpe)
      case tpe: TermRef => adaptTermRef(tpe)
      case tpe: ThisType => tpe
      case _ => tpe
    }

    override def adapt(tree0: tpd.Tree, pt: Type, original: untpd.Tree)(implicit ctx: Context): tpd.Tree = {

      // Find out what type the default typer thinks this tree has.
      val tree = super.adapt(tree0, pt, original)
      val tpe = tree.tpe

      // Do our stuff to the type.
      val tpe1 = adaptType(tpe)

      // TODO: extra type check?

      //if (tpe1 eq tree.tpe) tree
      //else {
      //  val tree1 = tree.withType(tpe1)
      //  if ((ctx.mode is Mode.Pattern) || tpe1 <:< pt) tree1
      //  else err.typeMismatch(tree1, pt)
      //}

      /*val dontCheck = (
        pt == WildcardType
          || !tree1.tpe.exists
          || pt.isInstanceOf[ProtoType]
          // || tree1.tpe <:< defn.AnyValType   // classes may extend AnyVal, so we do have to check
        )

      if(dontCheck) tree1 else {
        // TODO check that tree.tpe <:< pt wrt. mutability
        tree1
      }*/

      if (tpe ne tpe1) tree.withType(tpe1) else tree
    }*/


    /*
    ATTEMPT 2: FAILED.
    Using "shadow members" as separate things from normal members is obviously complicated,
    as it would involve replicating (at a minimum) the implementations of findMember and isSubType.

    However, using adaptApplyResult as a hook into realApply seems like a very good way to extensibly
    handle viewpoint adaptation. In realApply, we have access to the receiver, the result, the
    method denotation, and all arguments.


    def mergeShadowMutabilities(pre: Type, inf: Type)(implicit ctx: Context): Type = OrType(pre, inf)

    // For TermRefs: viewpoint-adapt the prefix.
    def adaptTermRef(tpe: TermRef)(implicit ctx: Context): Type = {
      val prefix = tpe.prefix
      val prefixMember = prefix.findShadowMember(MutabilityMember, NoPrefix)  //, tpe.widenIfUnstable)
      if (prefixMember ne NoType) {
        val unadaptedMember = tpe.findShadowMember(MutabilityMember, NoPrefix)  //, tpe.widenIfUnstable)
        val adaptedMember =
          if (unadaptedMember eq NoType)
            prefixMember
          else
            mergeShadowMutabilities(prefixMember, unadaptedMember)
        tpe.setShadowMember(MutabilityMember, adaptedMember)
      }
      tpe
    }

    // For ThisTypes: viewpoint-adapt based on enclosing-scope annotations.
    def adaptThisType(tpe: ThisType): Type = {
      tpe
    }

    def adaptAnnotatedType(tpe: AnnotatedType)(implicit ctx: Context): Type = {
      if (tpe.annot.symbol eq defn.ReadonlyAnnot) {
        tpe.setShadowMember(MutabilityMember, defn.AnyType)
        //RefinedType(tpe.underlying, MutabilityMember, TypeBounds(defn.NothingType, defn.AnyType))
        tpe
      }
      else
        tpe.derivedAnnotatedType(adaptType(tpe), tpe.annot)
    }

    def adaptType(tpe: Type)(implicit ctx: Context): Type = tpe match {
      case tpe: AnnotatedType => adaptAnnotatedType(tpe)
      case tpe: TermRef if tpe.isStable => adaptTermRef(tpe)
      case tpe: ThisType => tpe
      case _ => tpe
    }

    override def adaptApplyResult(funRef: TermRef, res: Tree)(implicit ctx: Context): Tree = {
      println(s"Apply type = ${res.tpe}")
      println(s"Fun type = ${funRef}")
      val receiver = funRef.prefix
      val methodDefs = funRef.alternatives
      if (funRef.findShadowMember(MutabilityMember, NoPrefix) ne NoType)
        println(funRef.findShadowMember(MutabilityMember, NoPrefix))
      res.tpe.copyShadowMembers(funRef)
      res
    }

    override def adapt(tree0: tpd.Tree, pt: Type, original: untpd.Tree)(implicit ctx: Context): tpd.Tree = {
      // Find out what type the default typer thinks this tree has.
      val tree = super.adapt(tree0, pt, original)
      val tpe = tree.tpe

      //if (tree.isInstanceOf[tpd.Apply]) println(s"Apply type = $tpe")

      // Do our stuff to the type.
      val tpe1 = adaptType(tpe)

      // Return a tree with the new type.
      if (tpe ne tpe1) tree.withType(tpe1) else tree
    }
   */


    /*
      ATTEMPT 3 partial failure - Putting shadow member checking directly inside the type comparer
       is causing the statement "val c: C @readonly = new C" to interpret the RHS type as Object.
      This is probably due to the constraint solver being unable to find a type T where
       C <: T <: C @readonly. (But this doesn't make sense to me--it should be able to select
       either C or C @readonly and be OK.)

      One possible course of action here is to see where the constraint solver checks subtypes
       and try to figure out why it does this.

      A second course of action is to create a secondary type comparer in the DotMod extension
       and invoke it only when checking certain kinds of trees (e.g., assignment).

      Let's try both.

      New information: The statement above fails even if the custom addition to the type comparer
      is disabled. Perhaps the AnnotatedType itself is causing a problem?
      New information: Stripping the annotations doesn't change the result. Perhaps there is
      something wrong with findMember? (which is the only other place where significant changes have been made?)
      New information: Disabling the shadow-member early-exit in findMember makes the error disappear.
      New information: The shadow-member early exit is taken if the requested member is from Object
        (e.g., method <init>), since Object is the refinement parent of the shadow bases.
        Now trying to filter these requests so we don't get members of Object.

      SUCCESS: Filtering out members of Object in findMember's shadow-member logic seems to work.
        Now making annotation stripping optional.
    */


    /*
      ATTEMPT 3b partial failure - Passing the assignment "val e: C = d" where d is C @readonly.

      It is possible that I got the shadow-member check in the type comparer wrong...

      For tp1 <: tp2, if the shadow member exists only in tp2, then t1 is assumed to have the member == Nothing, which should always succeed.
      This is implemented.
      If the shadow member exists only in tp1, then t2 is assumed to have the member == Nothing, which should fail unless t1's member is also Nothing.
      This is not implemented.

      New information: The type comparer is updated to fix this problem, but there is no change in output.

      There is possibly something wrong with the representation of readonly:
      The current implementation uses isSubType to compare RefinedType bases, but maybe this won't give the correct
      result if we want two readonly types to compare equal... possibly, shadow member types should be manipulated
      directly rather than encased inside RefinedTypes.

      What we're after here must have the following relations:
        Readonly <: Readonly
        Untyped <: Readonly
        Untyped <: Untyped
      This is really only a single bit.

      As for polymorphism, we want to compare with an arbitrary type, but only wrt to readonlyness.
      Thus, type members.
      So we're back to comparing shadow types directly, rather than as refined members.
      (The problem with using RefinedTypes to hold these members is that I am skeptical that:
        Object { M <: Any }  <:  Object { M <: Any }
        ).
      So, findMember should still return the requested member early-exit (to get the shadowing effect),
      but I should do the following:
        - return the refinedInfo directly, rather than doing a findMember on the shadow base.
        - make the refinedInfo for Readonly have the property Readonly <: Readonly.
        - choose Nothing as the default refinedInfo. (to get Untyped <: Readonly and Untyped <: Untyped)

      New information: In trying to compare defn.NothingTyoe <: TypeBounds(...), isSubType returns false.
        defn.NothingType is a TypeRef rather than a ClassInfo, which doesn't seem to compare correctly.

      A possibility is to make both halves into covariant TypeBounds.

      SUCCESS: now Untyped <: Readonly returns true as expected.
      New FAILURE: There's now a failure in ReTyper#typedSelect where "new C" is reported
        incompatible with its prototype.
        The specific phase reporting the problem is "Ycheck".
      One option here is to temporarily disable phases after the typer, and deal with
        this issue later (if necessary).

      FAILURE: Still not getting an error on "val e: C = d" after disabling Ycheck options.
        It looks like there is an issue with the fact that I'm not duplicating types before
        setting their shadow members. Since I have "C @readonly" at a prior line, the TypeRef
        to C gets a shadow member, so the use of this TypeRef on the next line is interpreted
        as Readonly. The duplication is probably unnecessary for singleton types (since the
        singleton type means the same type everywhere), but duplication couldn't hurt.

      (Note: shadow members are now copied in Type#newLikeThis.)

      Still not getting the expected failure. The TypeRef to C is still getting a shadow member added.

      New theory: the call to ctx.uniqueNamedTypes.enterIfNew (which is invoked when I try to duplicate
      named types) is not returning a new Type object, but rather is returning the old object because
      the name and prefix are equivalent to the old Type object.
      One option: Attempt to add a flag that adds the new type regardless of prior cached objects.
      A second option: Create and add the object directly in duplicate method, using ctx.uniqueNamedTypes.enterIfNew as an example.

      FAILURE: Still no effect. The TermRef referring to d isn't reporting any shadow members.
      Possibly, changing tree types is not enough. We need to get the shadow types into the symbol info.
      Possibly: Change types in the symbol completer?
      New information: The underlying symbol info for "d" is in fact the correct type.
      The TermRef's prefix is the module type, so it (correctly) is not reporting any shadow members.

      New information: The type comparer calls baseTypeRef when tp2 refers to a class symbol.
      baseTypeRef (correctly) returns a reference to the class, but (incorrectly) fails to
      copy shadow members of the class. One way to fix this is to add a check for shadow members in
      this particular case block. But perhaps a better way is to modify the shadow member comparison
      to call findMember instead of merely doing a surface-level check on both types.

      Another possibility is to extend the type comparer. This way, we already know the name of the
      specific member we're searching for.

      SUCCESS: A type mismatch error is generated for "val e: C = d".
      ./tests/dotmod/viewpoint1.scala:7: error: type mismatch:
       found   : viewpoint1.C @readonly(viewpoint1.d)
       required: viewpoint1.C
        val e: C = d
                   ^
     */

	SUCCESS on the Dotty update.
	SUCCESS on a few of the standard tests.

	PROBLEM: Somehow, we're getting an ErrorType inside the mutability member info.
		During the neg_autoTupling test.
	New information: We're getting a type alias to ErrorType when looking up the mutability member
	  during viewpoint adaptation. Where are these mutability members being generated?
	  It seems that it is possible for a TermRef prefix to be an ErrorType, which
	  will return an alias to ErrorType if a type-member query is performed.
	SUCCESS: neg_autoTupling test is now reporting the correct number of errors.

	PROBLEM: pos_autoTupling is generating 1 error where 0 are expected.
	SUCCESS: The error was being generated on pattern matching. Solution was to make sure
	  type compatibility checks do not happen in Pattern mode.

	SUCCESS: Passes all 662 positive Dotty tests.


ISSUE CYCLE-1:

	ERROR: in tests/neg/cycles.scala. Stack overflow after line 19 involving findMember.

	New information: The cycle seems to be when looking for the mutability member
	inside type member T inside class B. (Although previous evidence indicates that
	the cycle causing the stack overflow is actually inside class C or D, searching
	for a solution to the cycle in class B may solve the problem.)

	New information: The actual cycle is looking for the mutability member inside T
	with prefix E.x. The specific line triggering the cycle is:
	"val denotTpe = tpe.member(MutabilityMember)" where tpe is a TermRef
	representing the selection "E.this.x", which is widened to "E.this.F#T",
	which has the bounds Nothing .. E.this.x.
	The difficult part of this cycle is that it occurs entirely within the
	original Dotty code (Types#findMember -> go(this) -> Denotations#findMember) --
	all DotMod tries to do is call findMember at an (apparently) unusual time.

	Actual code in example:
	class E {
      class F {
        type T <: x.type // old-error: not stable
        val z: x.type = ??? // old-error: not stable
      }
      lazy val x: F#T = ???
    }
	What is "old-error"? If x is eager rather than lazy, then Dotty triggers
	"error: cyclic reference involving value x".
	One option is to simply ignore this test case for now.
	 The facts that may make ignoring acceptable are:
	 - The type-projection operation # is known to cause type-correctness failures,
	   and it may be removed in future versions of Dotty.
	Another option is to try to determine whether there is:
	- a bug in findMember
	- a valid reason to disallow calling findMember in such cases
	  (and what defines "such cases" anyway?)

	Does findMember make sense for arbitrary type projections?

	New information: If I change the order of the lazy val to the following, everything works OK:
	class E {
      lazy val x: F#T = ???
      class F {
        type T <: x.type // error: cyclic reference involving lazy value x
        val z: x.type = ???
      }
    }

	Looks like a Dotty bug.

	SUCCESS: With the definition ordering in tests/neg/cycles.scala changed, all negative tests pass.

MUTABILITY EXTRACTION

	Is it possible to declare the mutability of one type to be the same as another type?

	val foo: Foo { type +$M = readonly }
	val bar: Bar { type +$M = foo.$M }

	Annotations:
	val foo: Foo @readonly
	val bar: Bar @mutabilityOf(foo)

	The type of bar is given a shadow member that is a TypeRef to the shadow member of foo, or:
	  TypeRef(TermRef(NoPrefix, foo), $M)

	Defining annotation:
		class mutabilityOf(val ref: Any @readonly) extends scala.annotation.Annotation
	The parameter "ref" is the term to extract mutability from.
	It is @readonly so that it can take an argument of any mutability.
	PROBLEM: Since the definition of mutabilityOf is loaded from a classfile, the current DotMod is not
	processing the @readonly on the ref parameter.

	One possible solution is to do annotation processing during lazy symbol completion.
	However, it is currently unclear how to make a clean compiler extension using this mechanism.
	Let's try it anyway.
	New information: The completer in SymDenotation is not getting called. How are we getting the type of "ref"?
	Let's see what the typer is actually doing with the "ref" parameter.
	New information: The mutability extraction/attachment is not even complete yet.
	I should finish this before trying to debug the last problem.

	Partial SUCCESS: The following test:
	  class C
	  val c: C @readonly = ???
	  val d: C @mutabilityOf(c) = c  // ok
	  val e: C = d  // error

	Reports the following errors:
	./tests/dotmod/neg/mutability_of.scala:7: error: type mismatch:
	 found   : mutability_of.C @readonly(mutability_of.c)
	 required: Any
	  val d: C @mutabilityOf(c) = c  // ok
	                         ^
	./tests/dotmod/neg/mutability_of.scala:8: error: type mismatch:
	 found   : mutability_of.C @mutabilityOf(mutability_of.d)
	 required: mutability_of.C
	  val e: C = d  // error

	Where is the definition of mutabilityOf getting typed?

	Definition is loaded by: requiredClass("dotty.mutabilityOfRef").typeRef
	Def. of requiredClass: base.staticRef(path.toTypeName).requiredSymbol(_.isClass).asClass
	Def. of typeRef: TypeRef(owner.thisType, name.asTypeName, this)

	New information: The @readonly part of the Any param type doesn't seem to be part of the mutabilityOf
	constructor signature at all. Perhaps it's not getting put into the classfile to begin with?
	Making the readonly class inherit from ClassfileAnnotation... no effect.

	Perhaps there's another route to getting mutability to appear in classfiles?
	A possibility: Representing shadow members as real type refinements (that wrap type expressions).
	Would there need to be some logic to set the "override" flag on refined members?

	FAILURE: Tried a refinement type in mutabilityOf:
		class mutabilityOf(val ref: Any { type $M$ <: readonly } ) extends scala.annotation.Annotation
	Same symptom is occurring -- it seems that "Any { type $M$ <: readonly }" is being interpreted as
	merely "Any" during the check. This is actually a symptom of a bigger issue: in general, for:
		val foo: Any { type _m = readonly }
		val bar: Any { type _m = readonly }
	foo is not compatible with bar. This is surprising because according to DOT, this should work.
	CORRECTION:
	The mutability-member name I was using contained the unicode symbol É± (code point 0x0271).
	Changed to an all-ASCII name, it works as expected. (weird bug).
	New information:
	The failure above is due to:
	1. Matching refinement members removed in TypeComparer on line:
		val skipped2 = skipMatching(tp1w, tp2)
	2. The DotMod type comparer extension finding a shadow member inside tp1w, but not tp2.

	One option is to do the mutability check at the top level only (e.g., in topLevelSubType, not isSubType).
	This option would be OK if we do not need to consider type member compatibility in subtype checks (which we do).
	Another option is to attempt the bigger problem of shadow members (see below).

	Another issue:
	Ondrej and I seem to be in agreement that the adaptation of TermRefs (and singleton types in general)
	should not be viewpoint-adapted.
	The interpretation of shadow members on singleton types is really that the underlying (widened)
	types have those members.
	The idea here is that shadow members become real members when they are widened to TypeRefs.

DISCUSSION OF REALIZATION OF SHADOW MEMBERS: What Shadow Members Mean

	Examples:

	C.this.type  -- is a singleton type

	C @readonly  -- becomes:
	C { type __MUTABILITY__ <: readonly }

	Given:
	val c: C @readonly
	c.x  -- has type: c.x.type { type +$M$ = c.$M$ }

	The following types can be wrapped in RefinedTypes:
	 TypeRef
	 RefinedType / RecType
	 AndType / OrType
	 PolyType? / TypeLambda?
	The following types cannot be wrapped directly, but should have their underlying types wrapped appropriately:
	 TermRef
	 ThisType? / SuperType?
	 SingletonType?


	One of the problems with refinement is that:
		{ type _M = Nothing } { type _M <: readonly } is compatible with { type _M = Nothing },
	which means that once we decide to add a member that declares a type to be Mutable,
	we can't arbitrarily override it.
	However: If we set the latter mutability to be equal:
		{ type _M = Nothing } { type _M = readonly }
	then the last (outermost) mutability seems to override the previous mutability.
	The handling of TypeAliases seems to behave a little differently than mere TypeBounds;
	  if we just set the latter bounds without an alias:
		{ type _M = Nothing } { type _M >: readonly <: readonly }
	  then _M is interpreted to be Nothing rather than readonly.
	Covariance should allow the desired subtyping relationship: { type _M = Nothing } <: { type _M = readonly }.

	Avoiding false negatives:
	Considering a type T without the member _M, we have:
		T { type _M = readonly } <: T
	which is incorrect.
	Probably what we should check for during subtyping is: If the lesser type is a refinement of member _M,
	and the greater type does not define member _M, then we force return false if the lesser type's version
	of _M isn't Nothing. (We should do this check in isSubType before calling super.isSubType for the best performance.)

	Widening and type refinements:
	A big issue that I have to solve here is how to deal with widenings (which need to be viewpoint-adapted).
	The current solution is to handle widenings by using shadow members on TermRefs.
	This is no longer the current solution. It should be possible to perform viewpoint adaptation without shadow members.

	Where viewpoint adaptation happens:
	Currently, the place where viewpoint happens is when the underlying type of a NamedType is taken.

	Where annotations can occur:
	Pursuant to email conversation with Ondrej, annotating singleton types doesn't make sense (since a
	singleton type contains, by definition, exactly one type). The criterion for annotation is the
	same as the criterion for refinability: if the type can be refined, then we allow an RI annotation
	to be placed on that type.
	The following can be annotated:
	- TypeRef
	- PolyParam
	- RefinedType / RecType
	- HKApply
	- TypeVar ?
	- AndType / OrType
	- AnnotatedType
	Some types cannot be annotated directly, but their underlying types participate in viewpoint adaptation.
	The following cannot be annotated, but they can be the target of a viewpoint adaptation:
	- ExprType
	- TypeAlias / TypeBounds
	- TypeLambda
	- WildcardType

	SUCCESS: in doing basic viewpoint adaptation with type refinements rather than shadow members.
	Deprecated code (for adding & viewpoint adapting shadow members):
	/*
    /**
      * If tpe is an annotated type, finds the meaning of RI annotations.
      * If there is a meaningful RI annotation, sets the first non-annotation underlying type's
      * shadow member.
      *
      * Returns a version of the type that has shadow members, but is stripped of all RI annotations.
      */
    def toShadows(tpe: Type, shadowInfo: Type)(implicit ctx: Context): Type = tpe match {
      case tpe: AnnotatedType =>
        if (tpe.annot.symbol eq defn.ReadonlyAnnot)
          tpe.derivedAnnotatedType(toShadows(tpe.underlying, ReadonlyType), tpe.annot)  // leave RI annotations in place (for now)
        else if (tpe.annot.symbol eq defn.MutabilityOfAnnot) {
          val argTpe = typed(tpe.annot.arguments.head).tpe
          val newShadowInfo = argTpe.member(MutabilityMemberName).info
          tpe.derivedAnnotatedType(toShadows(tpe.underlying, newShadowInfo), tpe.annot)  // leave RI annotations in place (for now)
        } else
          tpe.derivedAnnotatedType(toShadows(tpe.underlying, shadowInfo), tpe.annot)  // leave non-RI annotations in place
      case _ =>
        if (shadowInfo.exists)
          tpe.duplicate.addUniqueShadowMember(MutabilityMemberName, shadowInfo, visibleInMemberNames = true)
        else
          tpe
    }

    def adaptType(tpe: Type)(implicit ctx: Context): Type = tpe match {

      case tpe: AnnotatedType =>
        toShadows(tpe, NoType)

      case tpe: TermRef =>
        if (tpe.prefix.isError)
          tpe
        else {
          // Check the prefix: We need to change the mutability of tpe only if tpe.prefix has a mutability member.
          val denotPrefix = tpe.prefix.member(MutabilityMemberName)
          if (denotPrefix.exists) {
            val infoCombined = {
              val denotTpe = tpe.member(MutabilityMemberName)
              if (denotTpe.exists) {
                // if prefix and tpe both have the shadow, combine their types with a union.
                val info1 = denotPrefix.info.asInstanceOf[TypeAlias].hi  // assume we've got type aliases here
                val info2 = denotTpe.info.asInstanceOf[TypeAlias].hi
                TypeAlias(OrType(info1, info2), 1)
              } else
                denotPrefix.info // only the prefix has a shadow
            }
            tpe.duplicate.addUniqueShadowMember(MutabilityMemberName, infoCombined, visibleInMemberNames = true)
          } else
            tpe
        }

      case _ =>
        tpe
    }
	*/

	FAILURE: Involving @mutabiliyOf.
	Test input:
	  class C
	  val c: C @readonly = ???
	  val d: C @mutabilityOf(c) = c  // ok
	  val e: C = d  // error
	Output:
	./tests/dotmod/neg/mutability_of.scala:7: error: type mismatch:
	 found   : mutability_of.C{__MUTABILITY__ =+ dotty.readonly}(mutability_of.c)
	 required: AnyRef{__MUTABILITY__ <: dotty.readonly}
	  val d: C @mutabilityOf(c) = c  // ok
	                         ^
	./tests/dotmod/neg/mutability_of.scala:7: error: type mismatch:
	 found   : mutability_of.C{__MUTABILITY__ =+ dotty.readonly}(mutability_of.c)
	 required: mutability_of.C{__MUTABILITY__ =+ mutability_of.c.__MUTABILITY__}
	  val d: C @mutabilityOf(c) = c  // ok
	                              ^
	./tests/dotmod/neg/mutability_of.scala:8: error: type mismatch:
	 found   : mutability_of.C{__MUTABILITY__ =+ mutability_of.c.__MUTABILITY__}(mutability_of.d)
	 required: mutability_of.C
	  val e: C = d  // error
	             ^
	SUCCESS:
	Needed to add special cases to the type comparer to handle refinements of the mutability member.
	In particular, when comparing tp1 <: tp2 where tp1 has a mutability member but tp2 does not,
	 ordinary subtyping logic simply ignores the member on tp1. What makes this a problem is that
	 if tp1 is not a RefinedType, but widens to a RefinedType, then the ordinary type comparer
	 will widen and then discard the refined type member without calling into the custom type comparer.
	 What we do now is take over the subtype comparison where tp1 widens to a RefinedType that
	 contains the mutability member. We do a findMember on tp2, compare the result with the widened tp1's
	 mutability member, then continue the subtype comparison on tp1's parent and tp2 (or tp2's parent
	 if tp2 is a refinement of the mutability member).
	The opposite case, where tp2 is a refinement of the mutability member but tp1 does not contain
	 the mutability member, is handled more simply. The default mutability is the bottom type mutable,
	 so we need only to check whether tp1 is compatible with tp2's parent.

	NOTE on viewpoint adaptation:
	For a denotation selection to be viewpoint adapted, two conditions must be met:
	- the selected denotation must be a term (not a type).
	- the type of the selected denotation must be an annotatable non-singleton type,
	 or a proxy for such a type.

	Revisiting the list of acceptable types for viewpoint adaptation:
	Types we should be able to refine:
	 - TypeRef
	 - RefinedType / RecType
	 - AndType / OrType
	 - PolyParam
	 - TypeVar
	 - HKApply
	Types where the underlying type may be refineable:
	 - AnnotatedType
	 - ExprType       -- viewpoint adaptation of result is needed so that arbitrary widenings produce a viewpoint-adapted result
	 - TypeLambda
	 - WildcardType   -- viewpoint adaptation may change the upper bound of the WildcardType.

	Question: does every non-overloaded denotation have a valid symbol?
	Answer: no, but we don't care--we're only looking at the type of the denotation, not its symbol.

ASSIGNABILITY

	What we're doing for assignability is to introduce a second type member that contains the mutability
	of the prefix type. There are now two type members we're using:
		__MUTABILITY__   -- the mutability of the type
		__PREFIX_MUTABILITY__   -- the mutability of the prefix type (if the type is viewpoint-adapted)
	The check for assignability is rather simple: If the info of the __PREFIX_MUTABILITY__ member is
	a subtype of mutable, then the type is assignable. Otherwise, it is not assignable.

	Implications for type comparison:
	If tp1 is a RefinedType, it is no longer sufficient to to just look at tp1's refinedInfo;
	the refinement no longer necessarily refers to the mutability member.
	Instead, it does a findMember on tp1 to capture any underlying refinements of the mutability member.

	Furthermore, if tp2 is a refinement of the prefix mutability, then subtyping unconditionally proceeds
	to tp2's parent type. The net effect is that the prefix mutability member itself has no effect
	on type comparisons. (Although the result of a findMember on this member is used to check assignability.)

	Other changes: moved the call to the viewpoint-adaptation hook to NamedType#info rather than
	TypeRef/TermRef#underlying. This change ensures that a calls to both info and underlying return
	a viewpoint-adapted result.

VIEWPOINT ADAPTATION

	Successful adaptation of method results by using @mutabilityOf(this). See polymorphic_mut test.

	Type comparer needed to be augmented to check TypeRefs that refer to the mutability member
	 of another type. It is possible that the mutability member does not exist on the
	 referred-to type, so such TypeRefs are defaulted to mutable before comparing.

	Method receiver mutability is not yet considered. Taking receiver mutability into account
	during viewpoint adaptation should be easy enough, but something will have to be done about handling
	the mutability of ThisTypes.


Implemented mutability of types with ThisType and NoPrefix prefixes.
PROBLEM: There seems to be some infinite recursion when trying to find the type of an annotation itself.
SUCCESS: The problem was that I was performing viewpoint adaptation on module references,
which was causing an infinite loop when trying to resolve the type of dotty.readonly.
Fortunately, it is unnecessary to perform viewpoint adaptation on modules.
FAILURE: Having problems with ThisType class names not actually appearing in context trees.
E.g., the members of object P {...} are actually in the synthetic class P$ { ... }.
 Perhaps I can trace the ownership chain through symbols instead of contexts.
 It is possible that there will be uncompleted symbols in the ownership chain,
 but if there is a way to get annotations from uncompleted symbols, that should work.
FAILURE: Tried using the symbol's originalName instead of name. Doesn't work.
It is possible that viewpoint adaptation really doesn't need to do this.

However, the issue here is that a use of "this" inside a method should have the appropriate mutability,
and that mutability varies depending on what method the "this" is used within.
If a method is receiver-polymorphic in a class C, we need this to have the type:
 C { __MUTABILITY__ >: mutable <: readonly }
The question that remains here is: given an arbitrary this-type, how do we reliably
determine what its mutability should be? Is it safe to traverse the owner-symbol chain
starting from the current context owner? It seems to be safe...
The mutability of C.this can be read from the enclosing definition whose symbol is non-weak,
 and whose effective owner is C. If there is no such symbol, then we are inside the constructor
 of C, so C.this is mutable.

PROBLEM: Discovered it is possible for the current context owner to not be contained in
the class we want to get the ThisType of. Perhaps what we want to do is have the ThisType
mutability computation start with a symbol that we know is inside the correct class?
SOLVED: Ignored (returned mutable for) package/root classes and inside constructors.

NOTE: I'm not calling mutabilityOf when processing the @mutabilityOf(x) annotation.
It causes cyclic reference errors. For the @mutabilityOf(x) annotation, the mutability
is exactly x.__MUTABILITY__ without any attempt to simplify.

Failing tests:
	assignability
	receiver
	assignable_mutability_of
Changed defn.MutableAnnotType to MutableType in assignability check. The assignability test now passes.

NOTE ON TYPE BOUNDS: It seems that, in general, type bounds are only comparable to other type bounds
(or type aliases). Comparing a type bounds type to a non-type-bounds type does not seem to work.
The reason seems to be that type bounds (and class infos) are type types, whereas most other types
are term (value/reference) types.

The failing case in the receiver test is the following:
  class C {
    @mutabilityOf(c) def mc() = ???
  }
  val c: C @readonly = ???
  c.mc()  // ok
I'm getting the following error:
	./tests/dotmod/neg/receiver.scala:15: error: Incompatible receiver mutability in call to method mc:
	  Expected: dotty.mutable
	  Got: receiver.c.__MUTABILITY__
I should be getting receiver.c.__MUTABILITY__ for the declared receiver mutability, not mutable. Why?
This test is no longer up-to-date. The @mutabilityOf annotations are not currently supported for
 receiver types in DOTmod. Instead, we are using @polyread.
However, an error is still happening on the same line:
./tests/dotmod/neg/receiver.scala:15: error: Incompatible receiver mutability in call to method mp:
  Expected: C.this.__MUTABILITY__
  Got: receiver.c.__MUTABILITY__
It is possible that a this-substitution of some sort needs to happen here. Unlike appearances of
"this" in the method signature (which are substituted on application), appearances of "this" on the
method symbol itself are not automatically substituted.
SUCCESS: Correct behaviour observed on the receiver test.

Representation of this-polymorphism: The mutability of "this" is different depending on where
it is being viewed from.

This-Polymorphism:
	Thinking about changing @polyread on methods back to @mutabiltyOf(this).
	Reasoning:
	A "this" is never just a "this". A ThisType is implicitly understood to contain a mutability member,
	a member that is defined by annotations on an enclosing method. Where a method explicitly
	declares @mutable, appropriate ThisTypes ought to return a mutability of mutable, and likewise
	for @readonly. @mutabilityOf(this) is no exception--the mutability declared is this.__MUTABILITY__.
	Uses of "this" inside such methods are therefore understood to have the type "this @mutabilityOf(this)",
	 or "this.type{ __MUTABILITY__ += this.__MUTABILITY__ }". The selection of the __MUTABILITY__ member
	 of "this" is "this.__MUTABILITY__", so the definition is circular. While the circularity may seem odd,
	 what this definition captures is that the mutability of "this" is exactly itself.

	 What the foregoing means for type comparison is that ... well, trying to work out the defaults
	 inside the type comparer may be very difficult.
	 What the type comparer really should know is that the bounds on this.__MUTABILITY__ are
	 mutable .. readonly. Setting such bounds ensures that the type comparer knows that
	 mutable <: this.__MUTABILITY__ <: readonly.
	 So in such cases, the mutability of "this" is both bounded and aliased.
	 (For arbitrary type aliasing, the default bounds are assumed to be Nothing .. Any,
	 so bounds don't actually have to be set explicitly. But here, if we want to make sure
	 everything works OK with mutable .. readonly bounds, we have to make sure that these bounds
	 are either inserted literally, or otherwise that all parts of the system understand that
	 these bounds are there.)

	 One possibility for making sure all mutability defaults are computed correctly is to allow
	 findMember itself to be extended.
	 Another possibility is to literally retype This trees to be type refinements that define
	 the desired mutabilities.

Current test status:
	All DotMod tests currently passing except for assignable_mutability_of.
	The following method should generate an error, but doesn't:
    @polyread def n(): Any @mutabilityOf(this) = {
      x = x   // error: this has polymorphic mutability
      x  // ok
    }
Also generating cyclic reference errors on standard Dotty tests.
The cyclic reference error seems to be due to an attempt to access annotations on a symbol
while finding a receiver mutability. Standard annotation access attempts to complete the
symbol, which causes the cyclic reference. Instead of forcing symbol completion, I will
check whether the symbol is complete, and if not, reach into the completer to find the annotation
trees. (I had something like this before, but I disabled it because it didn't seem necessary, which
was because I could access symbol ownership chains without causing an error. But it seems that
ownership chains only need access to the symbol denotation, not the denotation info.)
PARTIAL SUCCESS.

One of the negative tests is triggering a DotMod assertion:
	testing ./tests/neg/i1050a.scala
	assertion failure for Tiark1.V(Tiark1.v) <:< ?{ brand: ? }, frozen = false

	java.lang.AssertionError: assertion failed: Owners of val <local Tiark1$> do not contain expected class V

It seems that one of my assumptions was incorrect. Namely, that the current context owner is never
outside the class that we are trying to get the this-type for.
Since this error is happening during viewpoint adaptation (triggered by a findMember),
perhaps the symbol to start the search with is the member being found--but this would be incorrect.
We still want to return the mutability of the this-type from the current point of view.
Perhaps the best thing to do here is just return mutable if the current context is outside of the
ThisType's class. I'm not entirely convinced this is the right thing to do, so I'm issuing a
"WEIRD WARNING" so I can see if it's happening anywhere unexpected (if it only happens on inputs
that have other errors, then it's probably OK to do this).

Assertion error on tests/neg/zoo.scala.
Happens during receiver-mutability checking at method application. A call to the method
symbol's effectiveOwner yields NoDenotation.
The method application in question here doesn't actually have a method symbol.
(The neg/zoo test attempts to define and call methods structurally, which is not supported by Dotty at this time.)
Issuing a "WEIRD WARNING" on this case also.

MatchError during pos/Iter2.scala:
The erasure phase finds the type: RefinedType(RefinedType(TypeRef(TermRef(NoPrefix,$1$),scala$Tuple3$$T2), __MUTABILITY__, TypeAlias(TypeRef(ThisType(TypeRef(NoPrefix,dotty)),mutable), 1)), __PREFIX_MUTABILITY__, TypeAlias(TypeRef(TermRef(NoPrefix,$1$),__MUTABILITY__), 1))
which it tries to interpret as an array of mutable type. I.e.: []dotty.mutable
It blows up because it doesn't expect more than one refinement. See:
	TypeErasure.apply (RefinedType case).
	TypeErasure.eraseArray (in particular, the first line: "val defn.ArrayOf(elemtp) = tp").
	Definitions.ArrayOf.unapply (in particular, the line: "case at: RefinedType if (at isRef ArrayType.symbol) && at.argInfos.length == 1 => Some(at.argInfos.head)").
Mutability refinements shouldn't be considered arrays.
The quickest solution is to disable phases starting at erasure. Can't do codegen, but at least lets me get on with other things.
The next easiest solution to this issue is to remove mutability refinements before the erasure phase (as with Rytz' work).

Errors found on dotty compiler test:
	./src/dotty/./tools/dotc/core/Symbols.scala:562: error: illegal cyclic reference: alias ErrorSymbol.this.underlying.ThisName of type ThisName refers back to the type itself
	    type ThisName = underlying.ThisName
	         ^
	./src/dotty/./tools/dotc/transform/Pickler.scala:48: error: missing arguments for method addrOfTree in class TreeBuffer
	follow this method with `_' if you want to treat it as a partially applied function
	      pickler.addrOfTree = treePkl.buf.addrOfTree
	                                       ^
	./src/dotty/./tools/dotc/transform/Pickler.scala:49: error: missing arguments for method addrOfSym in class TreePickler
	follow this method with `_' if you want to treat it as a partially applied function
	      pickler.addrOfSym = treePkl.addrOfSym
	                                  ^
The first of these errors doesn't seem to interact with DotMod code at all. I'm going to ignore it for now.
Probably best to ignore tests other than standard pos & neg for now.

Another error:
./tests/pos/t1123.scala:8: error: non-private method f refers to private object extraListener
 in its type signature => AnyRef{__MUTABILITY__ =+ dotty.mutable; __PREFIX_MUTABILITY__ =+ Editor.this.extraListener.__MUTABILITY__}
    def f = extraListener.h
        ^
Temporary fix: Set __PREFIX_MUTABILITY__ to be either mutable or readonly (no path-dependent stuff).
Although it's probably not a complete solution.
Update: after adding better mutability defaulting (below), t1123 now passes. It passes because the mutability of path
Editor.this.extraListener now resolves to the mutability of Editor.this, which resolves to dotty.mutable.
However, t2435 (below) still fails.

Another error:
./tests/pos/t2435.scala:10: error: illegal cyclic reference: alias FConstant.this.tail.T of type T refers back to the type itself
    type T = tail.T
         ^
Probably from the same basic problem as the previous error.
Update: Probably not the same basic problem: still fails, but t1123 passes.

Maybe I've got to:
- add mutability members to all types where they're valid (during tree adaptation)
- look up mutabilities with findMember during viewpoint adaptation (rather than make TypeRefs)

What I actually did:
- Add checks in the type comparer where the mutability member is not defined:
  - if we're comparing a TypeRef with ThisType prefix, don't default to any other mutability.
  - if tp2 is the readonly type, or tp1 is the mutable type, pass the subtype with no further checks.
SUCCESS: All current DotMod tests pass.

Up next:
- test mutability of type bounds (abstract type members)
- ExprType annotations / viewpoint adaptation / receiver checking
- RefChecks?

Bugfix: Test pos/Map was failing because abstract type bounds now have an upper bound of readonly,
but like "==" were getting a mutable receiver by default. The fix is to whitelist certain method names.
Currently, all method names I find in Any and most in AnyRef are defaulted to polymorphic receiver mutabilities.
All methods in class AnyVal are also defaulted this way. AnyVal is a strange case because it's not a
reference type, but Scala allows it to be inherited.


DEFAULTING OF METHOD RESULTS:
	The only method that seems like it should be viewpoint-adapted by default is asInstanceOf[T].
	But even then, the result should be adapted only if the type T does not have a declared mutability.
	If T does have a declared mutability, can asInstanceOf[T] be used to force a the result to have
	a particular mutability?
	Actually, asInstanceOf is an ExprType, so viewpoint adaptation should already occur where other
	viewpoint adaptation is being done. However, the result of asInstanceOf is:
		PolyType(List(T0), List(TypeBounds(TypeRef(ThisType(TypeRef(NoPrefix,scala)),Nothing), TypeRef(ThisType(TypeRef(NoPrefix,scala)),Any))), PolyParam(T0))
	How do I adapt this kind of result?
		What we've got here is a polymorphic expression, which is a PolyType with an ExprType result.
	SUCCESS: asInstanceOf is now a safe method to call. Now, what about matching?

TYPE ERASURE AND MUTABILITY:
	What happens if I only remove __PREFIX_MUTABILITY__ members, and leave __MUTABILITY__members as they are?
	Do I get runtime mutability information, or more problems?


Problem: Defaulting parameterless methods to @polyread seems to be causing some errors,e.g.:
	./tests/pos/t2435.scala:9: error: type mismatch:
	 found   : String{__MUTABILITY__ =+ FConstant.this.__MUTABILITY__; __PREFIX_MUTABILITY__ =+ FConstant.this.__MUTABILITY__}(FConstant.this.constant)
	 required: String
	  case class FConstant[E <: FChain](constant:String, tail:E) extends FChain {
Perhaps there's a parameterless method call buried in the desugaring of the case class?
(There was a similar-looking error in pos/Map which I fixed by forcing a method receiver to be mutable.)
New information:
	When I disable the receiver defaulting for parameterless methods, I get a different error at about the same place:
	java.lang.AssertionError: assertion failed: error at ./tests/pos/t2435.scala:10
	type mismatch:
	 found   : String{__MUTABILITY__ =+ FConstant.this.__MUTABILITY__; __PREFIX_MUTABILITY__ =+ FConstant.this.__MUTABILITY__}(FConstant.this.constant)
	 required: Any
	tree = Ident(constant)
		at scala.Predef$.assert(Predef.scala:165)
		at dotty.tools.dotc.transform.TreeChecker$Checker.adapt(TreeChecker.scala:430)
		at dotty.tools.dotc.typer.ProtoTypes$FunProto.typedArg(ProtoTypes.scala:205)
		...
This looks like a bounds-checking error, where a non-mutable reference is not compatible with Any.
I did a search for all uses of defn.AnyType in dotc outside of dotmod, and got 30 results.
Possibly, I will need to make Any a readonly thing. Not sure what implications this has for asInstanceOf and matching,
but Any doesn't have any non-mutable-receiver methods, so at least method calls on Any in existing code should be OK.

New information:
Changed Any to be readonly in the type comparer, and the t2435 error went away.
 But now there is a remarkably similar error in Iter2:
	java.lang.AssertionError: assertion failed: error at ./tests/pos/Iter2.scala:206
	type mismatch:
	 found   : Int{__MUTABILITY__ =+ ArrayIterator.this.__MUTABILITY__; __PREFIX_MUTABILITY__ =+ ArrayIterator.this.__MUTABILITY__}(ArrayIterator.this.len)
	 required: Int
	tree = Ident(len)
		at scala.Predef$.assert(Predef.scala:165)
		at dotty.tools.dotc.transform.TreeChecker$Checker.adapt(TreeChecker.scala:430)
		...
This time, the required type is Int. Again, it involves a case class. The specific method causing the error is synthetic:
  override def hashCode(): Int = {
    var acc: Int = -889275714
    acc = scala.runtime.Statics$#mix(acc, scala.runtime.Statics$#anyHash(ArrayIterator.this.elems))
    acc = scala.runtime.Statics$#mix(acc, ArrayIterator.this.len)
    scala.runtime.Statics$#finalizeHash(acc, 2)
  }
The type mismatch is at the call to Statics$#mix(acc, ArrayIterator.this.len).
hashCode is considered to have a polymorphic receiver mutability, but the parameters to mix are mutable.
Perhaps the best solution here is to stop defaulting receiver mutabilities by name.
I could default these mutabilities by class (e.g., only for methods of Any/AnyRef/AnyVal/Object),
which would require overriding methods to be explicit about their receiver mutabilities.
Perhaps a different, more practical, solution would be to simply not check the receiver mutabilities
for these methods. Such a solution would allow mutating overrides of these methods, which means that
overriders would have to be careful not to introduce mutations.

Attempted to make @mutabilityOf(this) the default receiver and result mutability for parameterless methods.
However, this seems to break a lot of stuff (particularly in collections code--see pos/Iter2 test).

Perhaps in the interests of practicality, I should
1. leave the default receiver mutability for all methods as @mutable.
2. continue to viewpoint-adapt parameterless methods by default.
	Such methods can only be called on mutable receivers, unless otherwise annotated.
	Such methods can be safely overridden by vals (but not the reverse).
    (Viewpoint adaptation of an explicitly receiver-polymorphic result-mutability has no effect
    on the adapted result. The receiver this-type is substituted by the prefix type
    when the method is applied; the subsequent union of prefix mutability with result mutability
    produces no additional change in mutability.)
4. introduce a @fresh annotation for method definitions that indicates that:
	- The result of the method is not viewpoint-adapted.
	- The receiver and all other closed-over variables are non-mutable.

PROBLEM: When a method is called like an expression, a call to realApply is not generated. E.g.:

	def em(): C = ???
	def fm(): C = em()  // generates a call to realApply
	def gm(): C = em    // does not generate a call to realApply

Probably, the solution here is to check receiver mutabilities and adapt result mutabilities
at the time the method is selected (rather than at the time the method is applied).
The framing of this approach is: A method selection is valid only if receiver types are compatible.
(Rather than: A method application is valid only if ...)
This would ensure that receivers are checked and the correct result type is observed even if realApply is not called.

Update: It seems that the receiver-mutability check needs to happen after a tree is typed, but before
default tree adaptation logic occurs. The default adaptation logic may silently resolve parameterless-method
selections to their results, making it impossible to reliably check their receivers.

PROBLEM: Viewpoint adaptation is not correctly resolving the following:
		val g:D = dm.asInstanceOf[D @readonly]
	where dm is mutable. It does not produce an error here, but it should.
Upon closer examination, what's happening is that the selection of "asInstanceOf" sees an
underlying PolyType with an uninstantiated type parameter. Since the uninstantiated result
does not report having a mutability member (uninstantiated PolyParams return their origins?),
this points to a larger problem that could affect any viewpoint-adapted polymorphic method.
Interpolation happens in Typer#apply.
Perhaps the solution here is to extend adaptInterpolated rather than adapt, and do the
viewpoint adaptation there.

Update: The problem actually seems to be that the viewpoint adaptation code was refining
the uninstantiated PolyParam result with __MUTABILITY__ = mutable. When the PolyParam was
instantiated, the outermost mutable was still present, causing the type to be interpreted
as mutable regardless of the underlying type. The current implementation now refines the
mutability member only if the adapted mutability is different from the underlying.

All dotmod tests (including some new ones) now pass again.

Error: No errors being reported for tests/neg/i1050a.
Problem with refchecks extension maybe?
Fixed: As it turns out, the refchecks phase wasn't running. Now it is, and the test works correctly.

All positive Dotty tests now pass except for these three, which all seem to share a specific
kind of cyclic reference error:
    pos_t758()
    pos_t2698()
    pos_t2435()
Notably: the neg/i1240a test requires the erasure phase to be executing.
The following Dotty tests are now passing:
	pos_all  (with the exception of "illegal cyclic reference"-generating tests)
	neg_all
	new_all
	repl_all
	pickle_*
	compileStdLib
	compileMixed
	compileIndexedSeq
	dotc_ast
	dotc_config
	dotc_parsing
	dotc_printing
	dotc_reporting
	dotc_typer
	dotc_util
	tools_io
	java_all
	tasty_new_all
	tasty_runtime
	tasty_runtime_vc
	tasty_tools
	tasty_backend_jvm  (pre-existing caveat noted in tests file: "issue with ./src/dotty/tools/backend/jvm/DottyBackendInterface.scala")
	tasty_backend_sjs
	tasty_dotc
	tasty_dotc_ast
	tasty_dotc_config
	tasty_classfile
	tasty_tasty
	tasty_unpickleScala2
	tasty_dotc_parsing  (pre-existing caveat noted in tests file: "issue with ./src/dotty/tools/dotc/parsing/Parsers.scala")
	tasty_dotc_printing
	tasty_dotc_repl
	tasty_dotc_rewrite
	tasty_dotc_transform  (pre-existing caveat noted in tests file: "issues with LazyVals.scala, PatternMatcher.scala")
	tasty_typer  (pre-existing caveat noted in tests file: "issue with ./src/dotty/tools/dotc/typer/Namer.scala")
	tasty_dotc_util
	tasty_tools_io
	tasty_tests
The following fail:
	dotc_core, with the error (same for dotc_core_nocheck, tasty_core):
		./src/dotty/tools/dotc/core/Symbols.scala:562: error: illegal cyclic reference: alias ErrorSymbol.this.underlying.ThisName of type ThisName refers back to the type itself
		    type ThisName = underlying.ThisName
		         ^
	dotc_transform, with the error (in transform/PostTyper.scala):
		java.lang.ClassCastException: dotty.tools.dotc.core.Types$TermRefWithFixedSym cannot be cast to dotty.tools.dotc.core.Types$ThisType
			at dotty.tools.dotc.DotMod$.mutabilityOf(DotMod.scala:294)
			at dotty.tools.dotc.DotMod$.viewpointAdapt(DotMod.scala:413)
			at dotty.tools.dotc.DotMod$DotModTypeOpHooks.denotInfoAsSeenFrom(DotMod.scala:464)
			...
	tasty_dotty, with the error:
		java.lang.ClassCastException: dotty.tools.dotc.core.Types$RealTypeBounds cannot be cast to dotty.tools.dotc.core.Types$TypeAlias
			at dotty.tools.dotc.DotMod$.substThisMutability(DotMod.scala:398)
			at dotty.tools.dotc.DotMod$.viewpointAdapt(DotMod.scala:412)
			at dotty.tools.dotc.DotMod$DotModTypeOpHooks.denotInfoAsSeenFrom(DotMod.scala:464)
			...
<DISCUSSION: MUT_BOUNDS>
The last error is due to an attempt to compile the src/dotty/mutableOf file. It seems that none of the other
tests actually catch files in the top-level src/dotty directory. The issue is the declaration
	val ref: { type __MUTABILITY__ <: readonly }
which is a type bounds rather than a type alias.
What this really is is a way to express covariance in code. Since the internal representation of mutability
is a covariant type alias (see the earlier discussions of the problems of using type bounds internally to represent
mutability), it is probably correct to take the upper bound of the mutability member as the mutability.
SUCCESS: test tasty_dotty passes.

<DISCUSSION: SUPER_THIS_MUT>
For the dotc_transform error, the error shows up when trying to compile the following line in PostTyper.scala:
	superAcc.transformSelect(super.transform(tree), targs)
The supertype's this-type is somehow a TermRef(NoPrefix,$this) rather than an actual ThisType.
Is this a problem? Not necessarily... I can easily take the mutability of a TermRef as well as a ThisType.
There is, however, a question in my head about whether it is appropriate to do this.
Under what circumstances is a val $this created in lieu of a ThisType?
In any case, super and this refer to the same object. Regardless of what the underlying "this"-type is,
its mutability should be the same as the mutability of super.
SUCCESS: test dotc_transform passes.

DOTTY BUG discovered: Running some positive tests twice generates a stale symbol error during the erasure phase,
in an attempt to find the outer-accessor parameter of the class MapCanBuildFrom.
This error was not discovered earlier because the "twice" option is not enabled on batch tests (e.g., pos_all).
Notably, the following tests are known to fail:
	dotc/transform/PostTyper
	pos/Map
The output for pos/Map with "twice" is:
	dotty.tools.dotc.core.Denotations$StaleSymbol: stale symbol; method scala$collection$generic$GenMapFactory$MapCanBuildFrom$$$outer#22048 in class MapCanBuildFrom, defined in Period(20..34, run = 2), is referred to in run Period(34..34, run = 3)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.staleSymbolError(Denotations.scala:830)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.bringForward(Denotations.scala:646)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.currentIfExists(Denotations.scala:675)
		...
This is possibly a Dotty bug.
It has been replicated on the Dotty master branch.

New feature: Receiver mutability checking. (During RefChecks phase.)
Note: It looks like it may be possible to run the custom RefChecks phase as a miniphase instead of a standalone phase.

Problem with ThisType comparisons: When running the receiver_override test, the following error is improperly triggered:
	./tests/dotmod/neg/receiver_override.scala:16: error: Cannot override method n due to receiver mutability.
	   Overridden mutability: C.this.__MUTABILITY__
	   Overriding mutability: E.this.__MUTABILITY__
	    @polyread override def n(): Unit = ???  // ok
Probably, the type comparer does not make use of the fact that E is a subclass of C.
SOLUTION: There needed to be a substitution of E.this for C.this.
(See discussion of declared receiver types and substThis above.)

Information:
As it turns out, dotty does not let you override vals with defs.
The following code in RefChecks prevents it:
	if (other.isStable && !member.isStable) // (1.4)
		overrideError("needs to be a stable, immutable value")
The basic provision in this check is this:
	Unstable things cannot override stable things.
	(Purity may be similar: Impure things cannot override pure things.)
I suppose this provision allows the compiler to know that a field read is always a
field read, and not a method call.

<DISCUSSION: OVERRIDE_VAL_DEF>
On overriding: An adjustment needs to be done when checking receiver mutabilities during
overriding of a method/expr with a field. Specifically, a field's receiver is polyread (or mutabilityOf(this)),
which allows a value def to override a parameterless method def:
    @polyread def u: Any @mutabilityOf(this)
    ...
    override val u: Any   // should be OK
The result type comparison does not need adjustment because the result of val u is interpreted
as @mutable, which is a subtype of @mutabilityOf(this). Furthermore, vals can override vals without
problem (their receivers and result types evaluate to @mutable, which is technically incorrect,
but the point is that they are found to be compatible).
The opposite case, where a def overrides a val, is not supported here.


POLYMORPHISM, PART 2

Consider the following generic collection-like class:

  class C[T](elem: T) {
    @mutabilityOf[T] def get: T = elem
  }

The @mutabilityOf[T] here means that the receiver (this) has the mutability T#__MUTABILITY__.
(To avoid a name clash, the @mutabilityOf annotation above has been renamed @mutabilityOfRef.)

PROBLEM: Stack overflow.
	Overflow occurs when attempting to type the tree Ident(T) inside the @mutabilityOf annotation.
Cause:
	(in DotModTyper) adaptInterpolated is calling preChecks which is calling mutabilityOfThis
	on C.this in preparation for calling checkedReceiver.
	mutabilityOfThis is calling declaredReceiverType, which tries to type method annotations,
	causing a circular reference chain.
Diagnosis:
	checkedReceiver really only cares about selections of method symbols.
	So why are we finding prefix mutability for selections of non-methods (e.g., selection of named types,
	which we are doing here)?
SOLVED:
	Before asking for the mutability of anything, check whether the tree symbol really should have its
	receiver checked.

PROBLEM:
	The type argument T in @mutabilityOf[T] is not showing up in the arguments list.
CANDIDATE SOLUTION:
	Added a typedArguments method to the Annotation class that returns trees of type args.
NEXT PROBLEM:
	The argument T, when typed, triggers the following assertion in Typer#typedTypeTree:
		assert(isFullyDefined(pt, ForceDegree.none))
	According to the isFullyDefined documentation, false is returned if pt is a wildcard or uninstantiated type.
	Is there a way to get the type of the type argument without trying to type it directly?
SOLUTION:
	The type of @mutabilityOf[T] actually resolves to a RefinedType after typing.
	The refinedInfo of this type is a TypeAlias to the type we want.

Possibly need to rewrite the mutabilityOf method.

<DISCUSSION: POLYMORPHIC_2>
PROBLEM:
	Type comparer error:
	N#__MUTABILITY__ | T#__MUTABILITY__ is resolving to just T#__MUTABILITY__.
	Appears to involve defaulting these types to mutable in the type comparer.
SOLUTION:
	When finding mutability, don't use findMember right away.
	Instead, do a widenDealias, then see if the result is a TypeRef to an abstract/uninstantiated type member.
	If so, then make the mutability T#__MUTABILITY__ (where T is the uninstantiated type member).

	Also needed to add a special case to the type comparer.
	The case is similar to what had to be done for this-mutability.

	Also needed to loosen the refinement condition in viewpoint adaptation from
		if (finalMut ne tpMut)
	to
		if (finalMut ne defn.MutableAnnotType)
	Although logically it makes sense that we only need to change the mutability if it is different from
	what's already there, right now the type comparer doesn't always call mutabilityOf,
	so it doesn't always know that a type T should be understood to have mutability T#__MUTABILITY__.
FAILURE:
	Loosening the refinement condition in viewpoint adaptation causes Dotty tests to fail, notably
	dotc/core/Symbols, which reports 8 errors (of various types) instead of the previous 1.
NEW SOLUTION:
	Add a condition in the type comparer that any type T is assumed to have mutability T#__MUTABILITY__,
	unless overridden by another mutability. What this means practically is:
	In the type comparer, when tp2 is a mutability refinement with refinedInfo T#__MUTABILITY__, and tp1 is T,
	then the mutability check passes.
	Also, when tp1 is a mutability refinement with refinedInfo T#__MUTABILITY__, and tp2 is T,
    then the mutability check passes.

    Alternatively, if tp1 is a mutability refinement, compare its refinedInfo with mutabilityOf(tp2).
    Previously, the mutability of tp2 was approximated by a simple findMember with default to @mutable.
    Similarly, if tp2 is a mutability refinement, compare its refinedInfo with mutabilityOf(tp1).
    However, the type comparer has a case for special-casing Any to readonly when checking the tp2 refinement.
    Perhaps this special case should go into mutabilityOf instead?

SUCCESS: DotMod neg tests all pass again.

FAILURE in dotc/transform/PostTyper test:
	./src/dotty/tools/dotc/transform/PostTyper.scala:123: error: Incompatible receiver mutability in call to method tpe:
	  Expected: dotty.mutable
	  Got: T#__MUTABILITY__
	  private def fixSignature[T <: Tree](tree: T)(implicit ctx: Context): T = tree.tpe match {
	                                                                                ^
	./src/dotty/tools/dotc/transform/PostTyper.scala:125: error: Incompatible receiver mutability in call to method tpe:
	  Expected: dotty.mutable
	  Got: T#__MUTABILITY__
	      typr.println(i"fixing $tree with type ${tree.tpe.widen.toString} with sig ${tpe.signature} to ${tpe.widen.signature}")
	                                                   ^
	./src/dotty/tools/dotc/transform/PostTyper.scala:126: error: Incompatible receiver mutability in call to method withType:
	  Expected: dotty.mutable
	  Got: T#__MUTABILITY__
	      tree.withType(TermRef.withSig(tpe.prefix, tpe.name, tpe.widen.signature)).asInstanceOf[T]
	           ^
	./src/dotty/tools/dotc/transform/PostTyper.scala:126: error: value asInstanceOf does not take type parameters
	      tree.withType(TermRef.withSig(tpe.prefix, tpe.name, tpe.widen.signature)).asInstanceOf[T]
	                                                                                            ^
Perhaps what I've got to do here is expand T#__MUTABILITY__ to its upper-bound mutability (which should be mutable here).
We'll also see if that does anything to the fourth error above.
FIXED.

<DISCUSSION: ITER2_ASINSTANCEOF>
New errors in pos/Iter2:
	./tests/pos/Iter2.scala:143: error: type mismatch:
	 found   : AnyRef{__MUTABILITY__ =+ SA#__MUTABILITY__; __PREFIX_MUTABILITY__ =+ SA#__MUTABILITY__}
	 required: AnyRef
	        elems(i) = it.next.asInstanceOf[AnyRef]
	                                       ^
	./tests/pos/Iter2.scala:210: error: type mismatch:
	 found   : AnyRef{__MUTABILITY__ =+ dotty.readonly; __PREFIX_MUTABILITY__ =+ dotty.readonly}
	 required: AnyRef
	    private def widen(x: Any): AnyRef = x.asInstanceOf[AnyRef]
	                                                      ^
These errors have to do with the semantics of asInstanceOf.
I cannot determine whether these should or should not be errors -- more work on collection mutabilities is needed.

PARTIAL SUCCESS: Passes at least:
	all_dotmod_neg
	dotmod_failed_tests
	neg_all
Fails at least:
	tests/pos/annot-bootstrap

Going to finish work on collection mutabilities before trying to fix these errors.

DIAGNOSTIC on collection test failure:

The following generates an error as expected:
  class C[T] {
    @mutabilityOf[T] def get(): T = ???
  }
  val c: C[AnyRef@readonly] = ???
  val d: AnyRef = c.get()   // error

The following does not generate the error:
  class C[T] {
    @mutabilityOf[T] def get: T = ???
  }
  val c: C[AnyRef@readonly] = ???
  val d: AnyRef = c.get   // NO ERROR GENERATED

Printing key subtype comparisons (specifically, where either type matches RefinedType(_, MutabilityMemberName, _) or TypeRef(_, _);
	the "comparing" lines are entries into custom subtyping logic, "supercall" entries are exits to default logic):
The former has the following output immediately prior to the error:
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	./tests/dotmod/neg/collections/temp.scala:10: error: type mismatch:
	 found   : AnyRef{__MUTABILITY__ =+ dotty.readonly}
	 required: AnyRef
	  val d: AnyRef = c.get()
	                       ^
The latter has the following different output starting at the same position:
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to ?...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to AnyRef...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	supercall => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to AnyRef.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	supercall => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to Object.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing Object to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing <empty>.type to temp$...
	supercall <empty>.type to temp$.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing T to Any...
	comparing Nothing to T...
	supercall Nothing to T.
	comparing Nothing to Nothing...
	comparing T to Any...
	comparing Nothing to T...
	supercall Nothing to T.
	comparing Nothing to Nothing...
	comparing T to Any...
	comparing Nothing to T...
	supercall Nothing to T.
	comparing Nothing to Nothing...
	comparing temp.C[T] to dotty.mutabilityOf...
	supercall temp.C[T] to dotty.mutabilityOf.
	comparing temp.type to dotty.mutabilityOf...
	supercall temp.type to dotty.mutabilityOf.
	comparing <empty>.type to dotty.mutabilityOf...
	supercall <empty>.type to dotty.mutabilityOf.
	comparing <root>.type to dotty.mutabilityOf...
	supercall <root>.type to dotty.mutabilityOf.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Any...
	comparing Nothing to AnyRef{__MUTABILITY__ =+ dotty.readonly}...
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing Nothing to AnyRef...
	supercall Nothing to AnyRef.
	comparing Nothing to Object...
	supercall Nothing to Object.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing temp.type to temp.C...
	supercall temp.type to temp.C.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.

	The first question here is why we're not invoking more custom logic on "comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef."
POTENTIAL SOLUTION:
	It seems that a widen/dealias operation needs to be applied to both types in the comparision before
	attempting to trigger custom logic.
	Let's see if tests still pass.
PROBLEM:
	Broke compatibility when comparing mutabilities with type bounds (e.g., {__MUTABILITY__ <: dotty.readonly}).
POSSIBLY FIXED:
	Stopped caring about the lower bound of any mutability member info. Now using the upper bound of any member info as the correct mutability.
		(This should work since all mutability members currently in use are either covariant aliases, or otherwise upper-bound-only (e.g., <: readonly).
	Was also accidentally failing to check mutability members when both tp1 and tp2 contained them.
POSSIBLY FIXED WITH INCREASED CERTAINTY:
	collection_mut test now passes for the first time!
	all_dotmod_neg passes.
	dotmod_failed_tests passes.

CHANGED: mutabilityOf to always give a type alias or type bounds.
Update: Doesn't seem to really make any difference -- changing mutabilityOf back to returning non-bounds types.

<DISCUSSION: EXPR-ADAPTATION>
Why are we viewpoint-adapting ExprTypes? Since we're checking receiver types for ExprTypes, viewpoint-adaptation seems unnecessary.
The key issue to consider here is compatibility of field declarations and getters. See, e.g., from the simple_viewpoint test:
  class C {
    val x: AnyRef = ???
    @polyread def y = x
  }
The field x is automatically @polyread. The getter y needs to be annotated (unless we set a default).
For a discussion of overriding, see <DISCUSSION: OVERRIDE_VAL_DEF>.

<DISCUSSION: ASINSTANCEOF>
Since we're no longer doing viewpoint adaptation on ExprTypes (or PolyTypes), asInstanceOf is also no longer
viewpoint adapted. This change means that asInstanceOf remains useful for making exceptions to the default
RI typing regime, although (like case matching) it opens up the possibility of unintentional RI violations.
(See related <DISCUSSION: ITER2_ASINSTANCEOF>.)

<DISCUSSION: WIDEN-DEALIAS>
Pursuant to PROBLEM above: In the collection_mut test, we have:
  class C[T](elem: T) {
    val e: T = elem
    @mutabilityOf[T] def get: T = elem
    @mutabilityOf[T] def get2(): T = elem
  }
  class D
  val cdr: C[D @readonly] = ???
  val dr0: D = cdr.e       // Should give an error, but doesn't
  val dr1: D = cdr.get     // Should give an error, but doesn't
  val dr2: D = cdr.get2()  // error: type mismatch
The issue here seems to be that there is no automatic substitution/dealiasing of cdr.T (which should yield D @readonly)
during widening or viewpoint adaptation. (We do, however, have a corresponding substThis that does happen
during viewpoint adaptation [discussed earlier]).
The currently-implemented solution is to do a widenDealias on tp1 when checking for mutability member refinements
in the type comparer (where previously there was only a widen).
Interestingly, it seems that widening or dealiasing tp2 causes problems, but widening and dealiasing are necessary on tp1.

Known-passing tests:
	all_dotmod_neg
	dotmod_collection_mut
	dotmod_failed_tests (except for cyclic reference tests)
	pos/Iter2 now passes due to no longer viewpoint-adapting asInstanceOf
	neg_all

<DISCUSSION:ANNOTATION-TYPER-CONTEXT>
PROBLEM with annotation typing:
Consider:
  class C {
    class Extractor {
      @mutabilityOfRef(C.this) def get = ???
    }
  }
  val cr: C @readonly = ???
  val x: AnyRef = (new cr.Extractor).get
When typing the last line, we look up the annotation on Extractor#get, which contains the argument C.this.
Currently, the argument C.this is getting typed at the call to get, which means that dotty searches
for class C starting at the context that is current at the call to get. What we really want is to
type C.this at the original/creation context of method get.

dotmod_extractor test now triggers the following exception:
	dotty.tools.dotc.core.Denotations$NotDefinedHere: demanding denotation of class Extractor at phase patternMatcher(19) outside defined interval: defined periods are Period(21..24, run = 2)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.currentNoDefinedHere(Denotations.scala:753)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.current(Denotations.scala:746)
		at dotty.tools.dotc.core.Types$NamedType.computeDenot(Types.scala:1426)
		at dotty.tools.dotc.core.Types$NamedType.denotAt(Types.scala:1408)
		at dotty.tools.dotc.core.Types$NamedType.denot(Types.scala:1396)
		at dotty.tools.dotc.core.Types$Type.go$1(Types.scala:420)
		at dotty.tools.dotc.core.Types$Type.findMember(Types.scala:568)
		at dotty.tools.dotc.core.Types$Type.memberExcluding(Types.scala:405)
		at dotty.tools.dotc.core.Types$Type$$anonfun$member$1.apply(Types.scala:389)
		at dotty.tools.dotc.core.Types$Type$$anonfun$member$1.apply(Types.scala:389)
		at dotty.tools.dotc.util.Stats$.track(Stats.scala:36)
		at dotty.tools.dotc.core.Types$Type.member(Types.scala:388)
		at dotty.tools.dotc.DotMod$.substThisMutability(DotMod.scala:466)
		at dotty.tools.dotc.DotMod$DotModTypeOpHooks.denotInfoAsSeenFrom(DotMod.scala:514)
		...
Can this problem be fixed by moving substThisMutability elsewhere (e.g., inside viewpoint adaptation?)
SOLUTION:
	This problem is not really with substThisMutability at all.
	The problem is that when we try to type the annotation, we were using the current context's typer,
	not the typer/context that was in effect at the symbol where the annotation is used.
	So I added a field originalOuterContext to the Completer class, which allows me to type the
	annotations in the same context that defines the symbol.

	But what happens if the annotation uses a type or term parameter of the method itself?
	This does not seem to be a problem. Two examples of such dependence:
	    class Extractor {
          @mutabilityOf[T] def c[T](n: T) = ???
          @mutabilityOfRef(n) def c[T](n: T) = ???
        }
	The first (using @mutabilityOf[T]) triggers a "T not found" error.
	The error seems reasonable because the annotation is not really part of the method signature,
	 so it isn't clear to me whether it even makes sense for T to mean c's type parameter here.
	 (Would we be saying that an application of c would cause a substitution of T in
	 the annotation? That would make sense if we used @mutabilityOf[T] as a type annotation,
	 but as a symbol annotation it doesn't make sense.)
	The second compiles without problems.
TESTS:
	all_dotmod_neg passes.
	dotmod_failed_tests passes (again, except for cyclic-reference tests).
	pos_all passes.
	neg_all passes.
		Also turned all WEIRD WARNINGs back on. The following warnings exist:

		testing ./tests/pos/class-dependent-extension-method.scala
		WEIRD WARNING: Mutability of C.this is being requested from outside of class C. Assuming @mutable.

		testing ./tests/pos/valueclasses
		WEIRD WARNING: Mutability of ValueClass.this is being requested from outside of class ValueClass. Assuming @mutable.

		testing ./tests/neg/i1050a.scala
		WEIRD WARNING: Mutability of V.this is being requested from outside of class V. Assuming @mutable.

		testing ./tests/neg/i1050c.scala
		WEIRD WARNING: Mutability of V.this is being requested from outside of class V. Assuming @mutable.

		This is a notable drop in the frequency of such warnings.

	Fixed weird warnings: Instead of always starting the search for this-types from the current context owner,
	 I now pass a starting symbol to mutabilityOfThis.

	Cyclic reference tests now pass!

PROBLEM: dotmod_simple_viewpoint is broken.
FIXED: Prefix mutability during viewpoint adaptation now (again) starts from the current context owner,
	rather than the referred-to symbol. Mutability of the underlying type still starts from the referred-to symbol.

STUB warnings in the following tests:
	testing ./tests/dotmod/neg/mutability_of.scala
	STUB: Looking for outer-environment mutability at method o -- mutability_of.type(mutability_of) mutability was requested

	testing ./tests/dotmod/neg/polymorphic_mut.scala
	STUB: Looking for outer-environment mutability at package <root> -- polymorphic_mut.type(polymorphic_mut) mutability was requested

	testing ./tests/dotmod/neg/result_override.scala
	STUB: Looking for outer-environment mutability at class C -- result_override.C(C.this) mutability was requested
	STUB: Looking for outer-environment mutability at class D -- result_override.D(D.this) mutability was requested

	testing ./tests/dotmod/neg/value_override.scala
	STUB: Looking for outer-environment mutability at class C -- value_override.C(C.this) mutability was requested
	STUB: Looking for outer-environment mutability at class D -- value_override.D(D.this) mutability was requested

	Possibly, the first two of these tests reflect a failure to find the correct enclosing class due to
	use of effectiveOwner, which skips module/package classes. Perhaps we don't want to skip these classes?

	The second pair of these tests probably represents a failure to search the correct ownership chain.

New Information:
	Changing "effectiveOwner" to "lexicallyEnclosingClass" in the first ThisType case of mutabilityOf
	doesn't seem to change anything.
New information, in the polymorphic_mut test:
	1. There is an attempt to viewpoint-adapt the type TermRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,<empty>)),polymorphic_mut$)),cr).
	2. The request happens from the context owned by <root>.
	3. The request appears to happen from a search for matching implicits.
	   The original context owner before the implicit search is "val j".
	   The implicit search seems to be happening in an attempt to resolve a type mismatch caused by the assignment "val j = cr.ident()".
	4. Inside the implicit search, there is a call to namedPartsWith with context owner <root> on the type:
		ViewProto(RefinedType(TypeRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,<empty>)),polymorphic_mut$)),C), __MUTABILITY__, TypeAlias(TypeRef(TermRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,<empty>)),polymorphic_mut$)),cr),__MUTABILITY__), 1)),TypeRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,<empty>)),polymorphic_mut$)),C))
	EXPECTED SOLUTION:
		Just return @mutable if looking from the <root> context.
New information, in the mutability_of test:
	1. The stub warning occurs when trying to widen the type of "d" in the line ""@polyread def o(): C @mutabilityOfRef(this) = d".
	2. The widen operation is called inside "adapt" on tree Ident(d). The type being widened is:
		TermRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,<empty>)),mutability_of$)),d)
	The problem seems to be that the method o (which is the current context owner) is owned by class D,
	 not class mutability_of$. This points to some key unresolved issue with resolving mutability of ThisTypes.
Notes:
	We've got to rewrite how this-mutability is resolved. (This is a separate issue from purity and generalized outer-environment access.)
	Basically, the following needs to happen when determining the mutability @mutabilityOf(C.this):
	- If C.this is not being used as a prefix type (it is a standalone "this"), complete these steps with the context owner as the symbol.
	  Otherwise, complete these steps with the referred-to symbol.
	- CORRECTION: The mutability of C.this should always be computed from the current context.
	- Search for a pair of symbols that meets the following criteria:
	  1. The first element of the pair is a method. (Or other non-weak owner.)
	  2. The second element of the pair is a class.
	  3. The class is a base class of C.
	  4. The class is an owner of the method.
	  5. There are no non-weak owners of the method that are also owned by the class.
	- If the method has receiver-mutability annotations, return the mutability of the first annotation.
	  Otherwise, return @mutable.
	Edge cases:
	- The mutability of C.this is being requested from a primary constructor.
	  This should be OK, since primary constructors are methods named "<init>" (for classes) or "$init$" (for traits).
	  Although constructor method definitions are synthetic (not literally named in the source program),
	  they are methods nonetheless, and should be found by the above criteria.
	- CORRECTION: it is possible for searches to start directly at the class C's symbol (example: when looking for
		the mutability of PostTyperTransformer.this.parentNews, the context owner is PostTyperTransformer, not <init>.)
	Failure conditions:
	- Requesting the mutability of C.this inside C, but outside any method definitions.
	  This should not happen because all code inside the definition of C is assumed to be inside C's
	  primary constructor. In my current understanding, base-type declarations are already "outside"
	  C, so not referring to C; arguments to base types are resolved during construction, so will
	  have their types queried inside C's primary constructor. I'm putting in an assertion in case I'm wrong about this.
	- Requesting the mutability of a standalone C.this from lexically outside the the definition of C.
	  This should never happen. In source code, a "C.this" outside C causes an undefined-name error outside of C.
	  It should be an assertion if this happens.

<side topic>
mutabilityOf and translation of ordinary annotations:
1. receiver annotations should NOT call mutabilityOf, since mutabilityOf needs to query receiver annotations.
2. viewpoint adaptation calls mutabilityOf.
3. is there an issue with making sure annotation translations are consistent regardless of receiver vs. ordinary annotations?
4. should ordinary annotation translation call mutabilityOf, or generate annotations some other way?
Conclusion:
We don't need to call mutabilityOf directly during annotation translation.
We need to call something to parse the annotation itself, however.
Is there common code between ordinary annotation parsing and receiver-annotation parsing?
It looks the receiver-annotation code can be reused -- but special handling of @polyread is required.
	In particular, we need to define what @polyread means in arbitrary positions (not just in receiver-annotation positions).
	What I think needs to be done here is a search (in the current context) for the lexically enclosing class,
	and base the meaning of @polyread on the receiver of that class.

SUCCESS: ALL TESTS PASS!!


<DISCUSSION: OUTER-PURITY>

Introducing a new bit of information: __OUTER_MUTABILITY__,
which defines the default mutability of all variables outside the nearest enclosing class definition.
See dotmod/neg/collections/extractor test.

OR:
class setMutability[T <: Annotation](ref: Any @readonly) extends Annotation
as a method or class annotation.
Sets the mutability of ref to T when seen from inside the method/class. The given mutability must be a supertype of the original mutability of ref.
ALT:
class setTypeView[T](ref: Any @readonly) extends Annotation
Sets the type of ref to T when seen from inside the method/class. T must be a supertype of the original type of ref.

ASSIGNABILITY OF VARIABLES:
@setTypeView only covers mutability of variables, not assignability.
Assignability requires another annotation class. One possibility would have been to set the assignability
member (__PREFIX_MUTABILITY__) to be the same as the mutability member (__MUTABILITY__), but then we would lose
the option of making a viewpoint-adapted variable type both assignable and readonly (which could be very useful
if manipulating a reference to some non-owned object).

An issue with the generality of @setTypeView:
We can set T as an arbitrary supertype of ref.type only if ref is not assignable inside the setViewType-annotated method.
Otherwise, it would be possible to assign a type to ref that is not compatible with ref.
BUT: The fact that we can arbitrarily view ref with a super-mutability is OK --
 what's the difference? Does it have something to do with assignability? Or static vs. dynamic types?
THOUGHT EXPERIMENT:
	Think of each variable as an object with a single private field, a getter, and a setter.
	class V {
		private var v: T
		@polyread def getV = v
		@mutable def setV(_v: T): Unit = v = _v
	}
	The receiver type is the assignability (prefix) member.
	Say T is @mutable.
	If T were allowed to be upcast to @readonly, calling setV (assigning) to a @readonly member would be allowed.
	However: since it is possible to view v from a position where its type is @mutable, which would be a violation of mutability.
	So the mutability type is no different from the ordinary type.
	Possibly, assignment is a hole in the current implementation.
	However, ordinarily the only way to assign to a member with a non-original mutability is if its prefix type
	is non-mutable, and a non-mutable prefix causes assignment to be disallowed. So in the mutability space,
	this problem takes care of itself.

What the foregoing means for the assignability of a prefix-less type:
- A variable cannot remain assignable if its viewed type is not compatible with its original type.
- If a variable's viewed type is compatible with its original type, it may optionally be made unassignable.

An annotation for limiting assignability:
@asFinal(ref)     // for limiting assignability -- ref must be symbolic (a TermRef)
@asType[T](ref)   // for changing viewed type -- ref must be symbolic (a TermRef) -- (renamed from @setTypeView)

-->>> The use of @asType implies @asFinal if the given type T is not compatible with the original type of ref.

Where to perform viewpoint adjustment:
- One place to do viewpoint adaptation is where I've been doing it so far, which is when the type of a symbol is requested (Denotation#info).
- An alternative method of viewpoint adaptation is to insert asInstanceOf calls during adaptInterpolated.
  However, there are two things against this alternative method:
  1. Widenings are pervasive throughout the Dotty compiler (including inside member lookup, type comparison,
     and default tree adaptation). In my current understanding of the compiler, merely inserting asInstanceOf
     calls at certain trees would not do viewpoint adaptation on all places where widenings are performed.
  2. Doing viewpoint adaptation during the widening process itself is already implemented and debugged (at least to
     the extent that existing tests can catch bugs).
  Therefore, my first choice is to do viewpoint adaptation of variable types in the same place that I do viewpoint adaptation
  of receiver types.
Which means the following: Viewpoint adaptation of variable types ought to be done inside the mutabilityOf method,
since this is the same place that viewpoint adaptation of receiver references is done.
A special case needs to be made for NoPrefix reference types.

STACK OVERFLOW when attempting to compile neg/as_final test:
  var a: AnyRef = ???
  @asFinal(a) def m() = {
    a = ???  // error
  }
The unwanted recursion happens when typing @asFinal(a) itself.
Typing the argument "a" produces a widening in Typer#adapt, which triggers a call to findViewedType, which
attempts to find the annotations on the owner symbol "m", which triggers a recursive typing of @asFinal(a).
The problem here is that the context owner while typing annotations on m is m itself,
 which leads to recursion if an annotation has an argument whose type depends on annotations in the enclosing context.
 So why doesn't this happen with receiver-mutability annotations?
 Possible Answer:
 - It might happen now, because (e.g.) typing the @mutabilityOf(ref) annotation would trigger a call to findViewedType
   (whereas it didn't before).
TOWARD A SOLUTION:
What do we know about an annotation tree prior to typing? Answer: Not a lot -- syntax and names of things
	are in the tree, but prior to typing we don't have denotations or symbol info.
Can we do lazy typing for viewed types? YES!!!
	Now trying to cache lazy version of the viewed types.
Doesn't work.
	The real actual problem seems to be that the annotations are typed during widening.
POSSIBLE SOLUTION:
	Keep track of recursive calls to findViewedType on the same pair of (symbol, owner).
	Where a recursion is detected, return the symbol's original type (as if no annotations were present).
	FAILED: now a recursion happens when getting annotations inside declaredReceiverType.
NEXT SOLUTION:
	Track recursion in annotationsWithoutCompleting.
	If a recursive call to annotationsWithoutCompleting for the same completer is detected,
	then an empty annotation list is returned.
FAILED CHECK:
	exception occurred while compiling ./tests/dotmod/neg/as_final.scala
	java.lang.AssertionError: assertion failed: data race? overwriting symbol of type (()Unit)(D.this.m),
	long form = TermRef(ThisType(TypeRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,<empty>)),as_final$)),D)),m) of class class dotty.tools.dotc.core.Types$TermRefWithSignature,
	last sym id = 4676, new sym id = 4677,
	last owner = class D, new owner = class D,
	period = frontend at run 2
		at scala.Predef$.assert(Predef.scala:165)
		at dotty.tools.dotc.core.Types$NamedType.checkSymAssign(Types.scala:1481)
		...
As it turns out, the assertion happens when method m is declared twice, but somehow is not caught by ordinary error checking:
  class D {
    def m() = {
    }
    def m() = {
    }
  }
I'm not going to worry about this now, since it's not a valid program anyway.
But the illegal cyclic reference is also back:
	./src/dotty/tools/dotc/core/Symbols.scala:563: error: illegal cyclic reference: alias ErrorSymbol.this.underlying.ThisName of type ThisName refers back to the type itself
	    type ThisName = underlying.ThisName
	         ^
Temporarily disabling the search for @asType annotations -- @asFresh left intact.

What if I stopped typing annotations eagerly?  <DISCUSSION: CONTEXT-FOR-ANNOT-TYPING>
The reason is that (in all cases we currently care about) we really want to type method/class annotations not
under the enclosing context (the method/class itself) but under the enclosing's outer context.
The only reason I haven't done this already is that annotations unrelated to RI are not necessarily typed
this way, so I can't just type all annotations in the outer context. (I would risk incorrectly generating
errors in unrelated annotations.)
BUT -- if I could first extract the name of an annotation before attempting to type it, I could at least
make sure I don't inadvertently type an annotation with an unrecognized name. This is not quite a 100%-proof
situation, since it is possible for someone to create different (incompatible) annotations with the same names as mine,
but the chances seem vanishingly small, since all of the following would have to be simultaneously true:
- my DotMod extension would have to be active.
- the source program would have to use an annotation with the same name as an annotation recognized by DotMod.
- the source program would have to supply an argument to that annotation that must be typed in the immediate
  context (e.g., the argument would have to be a parameter of the immediate class/method).
By not typing in the immediate context, giving arguments that refer to a parameter in the immediate context
would generate errors. However, this shouldn't be a problem -- if the programmer wants to declare something
about a parameter, the parameter is immediately present. Parameters are always final (so asFinal is not
relevant), and named parameters in class/method definitions are always given a type (so asType is not
relevant).

<DISCUSSION:LAZY-NON-COMPLETER>
If I re-enable @asType annotations during viewpoint adaptation, I get cyclic reference errors again in dotc/core/Symbols.
Does this error have to do with denotations? I.e., how are cyclic references detected?
(Note: The cyclic reference seems to be happening inside the Scala2x unpickler.)
NEW INFORMATION: Looks like we're getting a LazyType that's not a Typer#Completer from SymDenotations#infoOrCompleter,
and so we inadvertently force completion.
NEW INFORMATION: We are getting a LazyType, which is not a Completer but an anonymous class.
This presents a problem because LazyType does not provide a way to get at the original creation context.
POSSIBILITY:
Is the context given to the SymDenotations#SymDenotation method the original creation context?
(The SymDenotation method is the only way given to create instances of the SymDenotation class.)
If so, maybe we can store this context as a field in SymDenotation (rather than reaching into a LazyType).
Unfortunately, it looks like the context we get when calling SymDenotation is the context _containing_ the
symbol, not the context created _for_ the symbol, which means that there is not an easily accessible tree
that we can look at to find the uncompleted annotations.
A DISCOURSE ON TREES AND SYMBOLS
Not all symbols have trees. (E.g., symbols that are loaded from classfiles.) This may seem to present
problems with getting annotations, but since we always search for annotations starting from the current
context, it's actually not an issue. Although we can look at symbols from other files, all
annotations that pertain to the symbol are always in current/enclosing contexts (i.e., annotations
that may be present in other files never change how the symbol is interpreted in the present context).
SOLUTION:
If we get a LazyType that's not a Completer, we always return an empty annotation list.
I am assuming that the only annotations we ever ask for are from current or
enclosing context owners. I am also assuming that all such owners are either method or class
definitions, which always use a Completer if incomplete. Which means the following:
- RI annotations on type members are disallowed.
- If I get a LazyType that's not a Completer, then the symbol cannot be a method or class.
- If I want to get annotations on fields/variables, I _should_ force completion. (But I don't define any annotations that are meaningful on fields/variables.)

<DISCUSSION:SYM-ANNOT-COMPLETER>
Unfortunately, the standard annotation completer does not know about our custom typing rule for asFinal and asType
(namely, that they should be typed in an outer context rather than the current context).
The (at least temporary) solution here is to override Typer#completeAnnotations, and
complete the annotations with ctx.outer rather than ctx. Although this move means that annotations
with arguments that refer to immediate method/class parameters will no longer work, I have yet
to see a convincing argument that such annotations are useful.
(as_type and as_final tests now pass.)

<DISCUSSION:GETTING-ORIGINAL-SYMBOL-TYPE>
ERROR in dotty test:
	./src/dotty/./tools/backend/sjs/ScopedVar.scala:20: error: Cannot perform assignment; variable value is effectively final due to an @asFinal or @asType annotation.
	      scVar.value = value
	                  ^
	./src/dotty/./tools/backend/sjs/ScopedVar.scala:27: error: Cannot perform assignment; variable value is effectively final due to an @asFinal or @asType annotation.
	      scVar.value = oldValue
	                  ^
The original type of scVar.value is the type parameter A, but in both instances here it is seen as type parameter T.
Why is the subtype test failing?
SOLUTION:
	It's failing because I was finding the original type by sym.info,
	where I should be using tpe.denot.info, where tpe is the LHS type of the assignment.
	Simply: tpe.info gives the viewpoint-adapted denotation type, and tpe.denot.info gives the
		unadapted denotation type (although with a possibly-adapted prefix).
	Getting the raw sym.info does not compute the necessary asSeenFrom calls.

<ISSUE:ANNOTATIONS-EARLY-TYPING-IN-METHODS>
FAILURE on the following test case:
  def M(): Unit = {
    var y: AnyRef = ???
    @asFinal(y)   // why can't we find y here?...
    def n() = {
      y = ???     // if we assign to to y here?
    }
  }
Debugging, I find that the owner of completion context for y is M (which is what I expected).
If I change M to a class (rather than a method), it works.
If I wrap def n() in another method or class (so that y is 2 levels out), it works.
If I give n() a result type (e.g., def n(): Unit), it works.
If I change n to a class (rather than a method), it works.
If I change y = ??? to just y, it works (but if I also add an @asType[T](y), it again complains that y cannot be found).
SO: The only case that seems to be failing is where: n does not have a declared result type,
n has an @asFinal(y), y is defined in the immediate enclosing context,
and the owner of the immediately enclosing context is a method.
POSSIBLE AVENUES OF EXPLORATION:
- Does this error happen in vanilla Dotty? (Answer: Probably not... we don't get a problem unless we force
  early typing of an annotation.)
- Is there something I'm missing about how/when variables are registered in method contexts?
IN ANY CASE: This doesn't seem like a critical issue -- in the worst case, adding annotations like
these will also require adding result types.


<DISCUSSION:PURE-ANNOTATIONS>
@pure is related to @asFinal and @asType.
If @pure is present on a method symbol s, then:
- All local variables defined outside of s are effectively final inside s.
- All local variables and method parameters defined outside of s are readonly inside s. (Except for variables that are explicitly annotated otherwise with @asType.)
- The receiver of s has polymorphic mutability inside s. (Unless explicitly annotated otherwise.)
- The this-mutabilities of all enclosing non-module classes have a polymorphic mutability inside s.
- All static fields are effectively final and readonly inside s.

@pure may be present on class symbols. If @pure is on a class symbol, then all of the same rules for
mutability and assignability apply, except for the receiver rule -- classes don't have receivers.

@pure does not say anything about parameters of the current method.
To "really" be pure, all parameters must have non-mutable types.
All parameters are already effectively final in Scala, so no provision needs to be made to restrict assignability of parameters.

What does @pure mean for local variables that are neither inside nor outside a symbol s? E.g., in a method of a different file?
One answer is that it does not matter what @pure means for these variables, since they are inaccessible inside s.
However, this answer is wrong because it is possible to call other methods from within s, and it is possible to override s.
@pure ought to treat all variables not inside s as being outside s.

When calling a method, the called method must either be pure, or it must be inside the innermost-enclosing
context-owner that's annotated @pure.

When overriding a method, the overriding method must either be pure, or it must be inside the innermost @pure symbol
that encloses the overridden method, or it must be inside a @pure-annotated subclass of the innermost @pure symbol
that encloses the overridden method. For an example of this last case, see:

	@pure class C {
		def m() = ...
	}
	@pure class D extends C {
		override def m() = ...  // ok because D.this is the same object as C.this, and D.this is @pure
	}

What we want to do here is:
1. Check ClassDefs to ensure impure classes are not extending pure base classes?
   I'm skeptical that this is really necessary if we're already (correctly) checking calls and overrides.
2. isContainedIn is insufficient. Every time we look at a @pure class symbol in the ownership chain,
   we've got to check superclasses to see if the sought-after purity boundary is among them.

Actually, what if we did a subtype test on all method receivers (during call checking)?

Here's another example:

	@pure class C {
		class C1 {
			def m() = ...
		}
	}
	@pure class D {
		class D1 extends c.C1 {
			override def m() = ...  // error: not within the purity boundary C (b/c D doesn't extend C).
		}
	}
	val c: C = ???

all_dotmod_neg test and dotmod_failed_tests are known-passing.
New test dotmod_pure_basic is working, pure_refchecks is not quite working.

<DISCUSSION:RECEIVER-MUTABILITY-SAME-OBJECT>
./tests/dotmod/neg/pure_basic.scala:64: error: Incompatible receiver mutability in call to method n:
  Expected: C1.this.__MUTABILITY__
  Got: D1.this.__MUTABILITY__
      super.n()
            ^
C1.this and D1.this really ought to denote the same object here.
What's happening in the receiver mutability checking code?
Apparently solved: by doing a simple substitution of receiver mutability. The substitution used is different than
  the substitution used in viewpoint adaptation... perhaps worthy of further investigation (to find similarities/differences between the different this-substitutions)?


<DISCUSSION: ANNOTATION TYPING ISSUE related to @asType/@asFinal>.
  Error in  dotmod_as_type test:
	dotty.tools.dotc.ast.Trees$UnAssignedTypeException: type of Ident(a) is not assigned
		at dotty.tools.dotc.ast.Trees$Tree.tpe(Trees.scala:137)
		at dotty.tools.dotc.DotMod$DotModTyper$$anonfun$customChecks$1.apply(DotMod.scala:946)
		at dotty.tools.dotc.DotMod$DotModTyper$$anonfun$customChecks$1.apply(DotMod.scala:945)
		at scala.collection.immutable.List.foreach(List.scala:381)
		at dotty.tools.dotc.DotMod$DotModTyper.customChecks(DotMod.scala:945)
		...
The Ident(a) tree is an @asType annotation argument.
What's strange about this error is that we do in fact have a tpd.Tree (not an untpd.Tree),
and yet the tree has null for its myTpe field.
It's not coming from my early-annotation-typing code - the early-typed annotations always type the arguments.
It's actually coming from the annotations I get from calling SymDenotations#annotations.
Why aren't the annotations I get here fully typed?
The only reason I can think of for this behaviour is to allow extension-writers the option of _not_ typing annotation arguments...
This behaviour causes me a problem, however - I want the annotation arguments not only typed, but typed in a particular context
  (specifically, the context enclosing the method context). Typing annotation arguments lazily won't work,
  particularly since we lose the original typing context (which is in the Completer) when the method symbol is completed.
Perhaps the solution here is to override the Typer's default annotation typing, and force annotation argument to be completed there.
  I would only want to force argument typing on particular annotations, namely @asFinal and @asType.
  New information: As it turns out, I've already overridden Typer#completeAnnotations. I'll force argument typing there.
  Update: I do not know of a way to directly set the type of an annotation tree from here.
  Solution: Use derivedAnnotation to generate new annotations with newly-typed trees inside the early-annotation-typing code.
  But, we still do not have access to the right context. I suppose it makes sense that we wouldn't necessarily have a context
  where we don't have a Tree (which would happen where the annotation is loaded from a classfile).
  A possibility: Use SymDenotations#transformAnnotations (setting annotations directly is not allowed outside of dotc.core).
Still doesn't work. Error message:
	java.lang.AssertionError: assertion failed
		at scala.Predef$.assert(Predef.scala:151)
		at dotty.tools.dotc.typer.Typer$$anonfun$typedTypeTree$1.apply(Typer.scala:920)
		...
		at dotty.tools.dotc.core.SymDenotations$SymDenotation.transformAnnotations(SymDenotations.scala:270)
		at dotty.tools.dotc.DotMod$DotModTyper.completeAnnotations(DotMod.scala:1023)
		at dotty.tools.dotc.typer.Typer$$anonfun$typedDefDef$1.apply(Typer.scala:1100)
		...
The failing assertion is:
	assert(isFullyDefined(pt, ForceDegree.none))
in Typer#typedTypeTree, which is similar to a problem I saw above, which is the result of trying to type
the annotation's type argument. I only want to type the term argument so that I know what symbol
the argument is referring to.

One option: Find the name of the argument, and do the name lookup myself...
But this would require access to the original context also.

Strangely, this error does not occur on all @asType annotations.

HACK in place: When examining an annotation argument that doesn't have a type, force a temporary typing in
the current context. This _should_ be adequate for our purposes, under the following assumption:
We examine annotations during selection operations only. If the selected symbol is visible from the
current position, valid arguments of annotations on that symbol should also be typable/visible
(unless the argument refers to a private symbol -- but we'll cross that bridge later if we need to).

The only other thing I can think of is to dig into annotation trees during Typer#completeAnnotations,
identify arguments that should be typed, rebuild those annotation trees to contain typed (rather than
untyped) arguments, use Annotation#derivedAnnnotation to build new annotations, and use
SymDenotations#transformAnnotations to make the symbol's annotation list reflect the new annotations.
(Of course, I don't know exactly what would happen here if the annotations are loaded from a classfile.)


ERRORS in new tests:
	./tests/pos/t7426.scala:3: error: anonymous class Object{...} is compiled twice
	@foo(new AnyRef { }) trait A
	         ^
This is a low-priority bug. It appears to have something to do with the early annotation typing, and
fixing it would probably require figuring out how to type all annotation arguments exactly once.
I am temporarily moving this test back to the pending folder.


<STDLIB-ANNOTATION-EXPERIMENT>
Annotating List1:
Annotation ordering:
- @pure on IntList, List, Cons, Nil.
  The purity system feels a little inflexible.

Annotating Iter2:
When adding @pure to ArrayIterator#foreach, i.e.:
    @pure override def foreach(f: A => Unit): Unit =
      for (i <- 0 until len) f(elem(i))
I get the following error:
	./tests/dotmod/collections/Iter2.scala:180: error: value until is not a member of Int(0)
	      for (i <- 0 until len) f(elem(i))
	                ^
Perhaps there is a problem with implicit resolution?

Expanding to:
    @pure override def foreach(f: A => Unit): Unit = {
      var i = 0
      while (i < len) {
        f(elem(i))
        i += 1
      }
    }
Gives the error:
	./tests/dotmod/collections/Iter2.scala:182: error: value f does not take parameters
	        f(elem(i))
	        ^
The type of f at this position is expected to be a MethodType.
But we are getting: TypeRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,immutable)),Iter2$)),IterableTransforms$)
  where IterableTransforms is an implicit class.
It seems that Dotty assumes that the method type here to be either a MethodType or an ExprType,
  so it issues a "does not take parameters" if the type is not a MethodType.
So why are we getting a TypeRef here?
Up the stack trace, we have a call to Applications#isAsGood with both arguments being:
	TermRef(ThisType(TypeRef(ThisType(TypeRef(NoPrefix,immutable)),Iter2$)),IterableTransforms)
Up further, there is a call to adaptInterpolated with tree Ident(IterableTransforms) that has the foregoing type.
Up further. there is a typedExpr on this tree.
Never mind: this particular stack trace is inside a test application, so it is probably unrelated to the error displayed.

Let's look for the "does not take parameters" error issued from the type assigner.
Info: It does not look like the error is triggered from the type assigner. So where is it coming from?
Info: It looks like I can breakpoint it in TypedApply#fail.
Info: Nope, not there either.

New information:
There is actually a hidden error before the reported error:
	...
	*** ERROR: Cannot select method apply from here: It must be @pure due to the @pure on method foreach.
	./tests/dotmod/collections/Iter2.scala:182
	*** ERROR: value f does not take parameters
	./tests/dotmod/collections/Iter2.scala:182
	...
It looks like the context mode Mode.Printing was retracted at the time the purity error occurred.
Probable hypothesis: The typer tried to synthetically generate a call to apply.
  When that attempt failed, the typer reported that it could not call f without parameters.

SOLUTION: This is a defaulting problem.
Setting all members of Function, AbstractFunction, Tuple, and Product to being assumed @pure.
What consequences does this have for correctness? After all, it is possible to have an
impure function passed as an argument to a pure method. We can account for purity from the
point of view of the method's caller. The way I've defined @pure is the following:
@pure means that the method cannot interpret any reference it pulls from its environment
as either mutable or assignable. References obtained through parameters are not affected
by @pure, so it seems fairly coherent that references obtained through functions that are passed
as parameters may be allowed to be mutable and assignable. Conveniently, I allow assumed-pure
methods (which now include FunctionN#apply) to be overridden by impure methods (merely issuing
a warning rather than an error). This works for limited cases, but it seems hacky.

I wonder if there is somehow a way to usefully encode @asFinal/@asType information in reference types?
Right now, I'm restricting method selections based on their purity compatibility in the current context.
An Experiment:
	class C {
		def m() = ???
	}
	class D extends C {
		@pure def m() = ???
	}
	val d: D @readonly = ???
	d.m()  // ok
	val c: C @readonly = d
	c.m()  // error: expected receiver to be @mutable, got c.__MUTABILITY__
Trying the @pureAt annotation:
(The meaning of @pureAt(ths) is that ths and all enclosing this-references are polymorphic,
 and that all prefixless variables outside of ths are readonly. ths itself must have a ThisType.)
	class C {
		class D {
			@pure def m1(): Unit = {
				m2()  // ok: @pure on m1 is the same as @pureAt(D.this)
				m3()  // error: expected @mutable for D.this, got D.this.__MUTABILITY__
				n()   // ok: n has C.this.__MUTABILITY__ for C.this, and does not have access to D.this
				@pure def m1a(): Unit = {
					m1()   // ok: m1 is @pure
					m2()   // ok: m2 has D.this.__MUTABILITY__ for D.this, and does not have access to local variables of m1
					m3()   // error: expected @mutable for D.this, got D.this.__MUTABILITY__
					n()    // ok: n doesn't have access to D.this or local variables of m1
					m1b()  // error: m1b expects access to local variables of m1
				}
				m1a()  // ok: m1a is pure
				def m1b(): Unit = ???
				m1b()  // ok: m1b is within m1
			}
			@pureAt(D.this) def m2(): Unit = {
				m1()  // ok
				m3()  // error: expected @mutable for D.this, got D.this.__MUTABILITY__
				n()   // ok: n doesn't have access to D.this
			}
			@pureAt(C.this) def m3(): Unit = {
				m1()  // ok
				m2()  // ok
				n()   // ok
			}
		}
		@pure def n = ???
	}
Is it possible or reasonable to represent purity boundary (like mutability) as a type member of reference types?
Revisiting overriding, should the following override of method m1 be allowed?
	class C {
		class D {
			def m1() = ???
		}
		class E extends D {
			@pure def m1() = ???   // this-mutability is E.this, or @pureAt(E.this)
		}
		class F extends D {
			@pureAt(C.this) def m1() = ???  // how to check?
		}
		class G extends D {
			@asType[C@mutabilityOf(C.this)](C.this) def m1() = ???  // how to check?
		}
	}
	val c: C = ???
	val d: c.D @readonly = ???
	val e: c.E @readonly = ???
	d.m1() // error
	e.m1() // ok

	val cr: C @readonly = ???  // type of cr is C { __PURE_AT__ =+ what? }
	val cr_d: cr.D = ???  // type selection cr.D is viewpoint-adapted to: cr.D { __PURE_AT__ =+ what? }
	val cr_e: cr.E = ???
	cr_d.m1()  // error: expected @mutable receiver, got @pureAt(...)
	cr_e.m1()
Discussion: The basic idea behind purity is that:
Every reference is not merely a reference to a single object, but rather a reference implicitly
contains information about what's in its enclosing environment. Specifically, a reference to a
particular object of type D is associated with a reference to a particular object of type C.
(This is a given in path-dependent typing.) So the question becomes: When I'm in method of
class D (so I have a D.this), how do I determine the mutability of C.this?

The mechanism of @asType annotations seems sufficient to declare mutabilities of enclosing
object references, provided references of the form C.this are allowed as arguments.
(There are 2 things I'd want to change, however: (1) make @asType legal only for this-types
or no-prefix references [as opposed to allowing references to arbitrary fields], and
(2) stop forcing the type given for @asType to be a supertype of enclosing @asTypes
[current behaviour: the type argument of @asType must be a supertype of enclosing @asTypes for the same reference].)
Update: I suppose change (1) here isn't strictly necessary.

The annotation @pureAt can assign certain mutabilities to enclosing objects, as if a set of @asType annotations is present.

__OUTER_MUTABILITY__ = ???

Function example:
class Pkg {
	abstract class Function1[-A,+B] {
		@pure def apply(x:A):B  // can this be @pure? Yes. Specifically, we're looking at @pureAt(Function1.this).
	}
	class E {
		def doSomething(): Unit = {
			var v = 0
			class MyFn extends Function1[Int,Int] {
				@mutabilityOfRef(this) @pureAt(Pkg.this) def apply(diff: Int): Int = {  // what goes here? See below.
					v += diff; v
				}
			}
			val myFn$ = new MyFn
			myFn$.apply(3)
		}
	}
}
For the override of apply, it seems like we need to say that the overriding version is pure in every place
that the overridden version can see. In this case, the @pure on Function1#apply means that the receiver
mutability is polymorphic on both Function1.this and Pkg.this. Overriding, these constraints can be
respected by the annotations @mutabilityOfRef(this) @pureAt(Pkg.this).
Entailments: The purity-override checking must be updated to check enclosing references singly rather
than the current "if-overridden-is-pure-then-overriding-must-be-pure."
The definition of @pure itself is changed here - @pure now says nothing about references that it cannot see.
Unless: The functionality I'm after is fully encapsulated by @pureAt, and @pure (if used at all) means something stricter.

What about a different kind of annotation?
@nonMutable(ref) where ref is a this-type or prefixless variable.
If ref is a this-type, then @nonMutable(ref) means that the mutability of ref is ref.__MUTABILITY__.
If ref is a prefixless variable, then @nonMutable(ref) means that the mutability of ref is readonly.
Q: Can there be a uniformity of definition here where prefixless variables also have mutability ref.__MUTABILITY__?


What if we represent purity using some kind of polymorphic type parameter?
There are already facilities for type interpolation in Dotty.
And I previously had an example of polymorphic purity where I used a type parameter to represent the necessary relationships.


<POSSIBLE-BUG-SUPERTYPE>
Am I finding the mutability of a supertype correctly?
Yes.

<BACK-TO-RECEIVERS--TOWARD-PURITY>
(Toward purity) What kind of system/representation is needed to support purity, with consideration only of the immediate receiver?
E.g., consider the following, where apply is polymorphic, and apply2 is mutating:
	abstract class Function1[-A,+B] {
		@polyread def apply(x:A):B
		@mutable def apply2(x:A):B
		type __MUTABILITY__ = this.BLAH
		//type __MUTABILITY__ = readonly  // default for function classes
	}
	class E {
		def n() = {
			var v = 0
			class MyFn extends Function1[Int,Int] {
				@polyread def apply(diff: Int): Int = { v += diff; v }  // rcv. mut. is MyFn.this.__MUTABILITY__
				@mutable def apply2(diff: Int): Int = { v += diff; v }

				@mutabilityOf[this.BLAH] def apply3(diff: Int): Int = { v += diff; v }
				type BLAH = mutable
			}
			val e0 = new MyFn  // e0 is readonly due to type __MUTABILITY__ = readonly
			e0
		}
	}
	val e: E = ???
	val fn: Function1[Int,Int] = e.n()
	fn.apply(3)  // ok: apply is @polyread
	fn.apply2(3) // error: apply is @mutable
	fn.apply3(3) // ok: ... why?
	app(fn)  // ok: Function1 has type __MUTABILITY__ = readonly
	def app(fn: Function1[Int,Int]) = {
		fn(3)  // ok: apply is @polyread
	}
Trying again:
	abstract class Function1[-A,+B] {
		type __OUTER__ = mutable
		@mutabilityOf[__OUTER__] def apply(x:A):B
	}
	class E {
		def n() = {
			var v = 0
			// Pure
			val e0 = new Function1[Int,Int] with {
                type __OUTER__ = readonly
                @mutabilityOf[__OUTER__] def apply(diff: Int): Int = { v += diff; v }
            }
			// ImPure
			val e1 = new Function1[Int,Int] with {
                type __OUTER__ = mutable
                var w = 0
                @mutabilityOf[__OUTER__] def apply(diff: Int): Int = { w += diff; w }  // should this type-check OK?
                    // mutabilityOf(this) == this.__OUTER__#__MUTABILITY__
                    // q: is this.__OUTER__#__MUTABILITY__ <:< mutable?
            }
			e0
		}
	}
	val e: E = ???
	val fn = e.n()
	@mutabilityOfRef(this) def app(fn1: Function1[Int,Int] { type __O__ = +readonly }) = {
		fn1.apply(3)  // mutabilityOf(fn1) == fn1.__OUTER__#__MUTABILITY__
		              // receiver mutability == fn1.__OUTER__#__MUTABILITY__
		              // ok.
	}
	app(fn)

An important question: What happens when a closure is typed? (in the typer)


<ASSIGNABILITY-REVISITED>
I have defined primitive value types (like Int) to be non-refinable.
However, this causes problems during the assignability check -- the __PREFIX_MUTABILITY__ member is not present.
Looks like I will have to write a separate function assignabilityOf(tp) to avoid this problem.

<DISCUSSION: ABSTRACT-MUT-2>
In the following apply method, the mutability of E1.this is reported to be @mutable:
      class E1 extends F1[Int,Int] {
        override type __OUTER__ = readonly
        var w = 0
        @mutabilityOf[__OUTER__] def apply(diff: Int): Int = { w = w + diff; w }
      }
The problem here is that @mutabilityOf[__OUTER__] evaluates to:
	E1.this.__OUTER__#__MUTABILITY__
During type comparision, the bounds of:
	E1.this.__OUTER__
are requested, and since the upper bound is not Any, the mutability is deemed to be @mutable.
There are really two problems here:
	1. mutabilityOf() should be used to find the upper mutability bound of E1.this.__OUTER__, and
	2. "override type __OUTER__ = readonly" should really be "override type __OUTER__ = AnyRef@readonly"
		(the mutability member of __OUTER__ needs to be readonly; setting __OUTER__ to readonly directly would be a hack).
Incidental bug fix:
	- When comparing T1#__MUTABILITY__ with T2#__MUTABILITY__, type comparer now returns true if T1 is equivalent to T2.
Another incidental bug:
	./tests/dotmod/neg/pure_rcv_mut_2.scala:30: error: Incompatible receiver mutability in call to method apply:
	  Expected: M#__MUTABILITY__
	  Got: dotty.mutable
	    fn.apply(3)
	       ^
Which is no longer appearing. Ignoring.

<DISCUSSION:POLYMORPH-PURITY>
What I want is a conditional purity. Derivations of the basic function class should be allowed to be either readonly or mutable:
	class F1[M,-A,+B] { @mutabilityOf[M] def apply() }

	class MutableF1[-A,+B] extends F1[AnyRef,A,B] { def apply() ; type __MUTABILITY__ = mutable }
	class ReadonlyF1[-A,+B] extends F1[Any@readonly,A,B] { @readonly def apply() ; type __MUTABILITY__ = readonly }

Actual first-cut solution:
  // Using F1 as an experimental stand-in for Function1.
  abstract class F1[-A,+B] {
    type M >: Any@mutable <: Any@readonly
    @mutabilityOf[M] def apply(a: A): B
  }

  // ImPure and Pure extensions of F1
  class MutableF1[-A,+B] extends F1[A,B] {
    type M = Any@mutable
    private var _local_ = 0
    @mutabilityOf[M] def apply(a: A): B = { _local_ = 1 ; ??? }  // ok
  }
  class ReadonlyF1[-A,+B] extends F1[A,B] {
    type M = Any@readonly
    private var _local_ = 0
    @mutabilityOf[M] def apply(a: A): B = { _local_ = 1 ; ??? }  // error
  }

  // Calling various versions of F1
  val mutableF1: F1[Int,Int] { type M = Any@mutable ; type __MUTABILITY__ <: mutable } = new MutableF1[Int,Int]
  mutableF1.apply(3)

  val readonlyF1: F1[Int,Int] { type M = Any@readonly ; type __MUTABILITY__ <: readonly } = new ReadonlyF1[Int,Int]
  readonlyF1.apply(3)

  app[mutable](mutableF1)
  app[readonly](readonlyF1)
  app(mutableF1)
  app(readonlyF1)
  def app[N >: mutable <: readonly](fn: F1[Int,Int] { type M = Any { type __MUTABILITY__ = N } ; type __MUTABILITY__ <: N }) = {
    fn.apply(3)
  }

<OUTER-PURITY-REVISITED-AGAIN>
How does @pureAt[] really work?
Here's an example of a first-class function call:

	class C {
		@pure def m(ls: List[Int] @readonly) = {
			var sum = 0
			@pureAt[C] def add(i: Int) = { sum += i }  // mutates m's local vars
			ls.foreach(add)   // calls add on every element of ls
		}
	}

Possible annotations on List and Function1:

	class List[+A] {
		// type parameter R and purity annotations are added to the definition of foreach.
		@pure def foreach[R,U](f: Function1[A,U] @pureAt[R]) = f.apply(???)
	}
	abstract class Function1[-A,+B] {
		type __PURE_AT__   // this member is refined to R by @pureAt[R]
		@pureAt[__PURE_AT__] def apply(a: A): B
	}

@pureAt[] denotes the mutability of a list of references.
Say lexically we have:
	class C {
		class D {
			class E {
			}
		}
	}
@pureAt[D] means:
	- C.this is nonmutable
	- D.this is nonmutable
	- E.this is mutable
Since we seem to be talking about specific references, how about we use @pureAt(D.this) instead of @pureAt[D]?
What are the restrictions on calling?
	class C {
		@pureAt(C.this) def cm() = ???
		class D {
			@pureAt(D.this) def dm() = {
				D.this   // is @pureAt(D.this)
				C.this   // is D.this.outer, which is @pureAt(C.this)
				C.this.cm()  // ok: rcv is @pureAt(C.this)
			}
			class E {
				@pureAt(D.this) def em1() = {
					E.this   // is @pureAt(D.this)
					D.this   // is E.this.outer, which is @pureAt(D.this)
					D.this.dm()  // ok: rcv is @pureAt(D.this)
				}
				@pureAt(C.this) def em2() = {
					dm()  // Error: D.this is @pureAt(C.this) here, which is not compatible with @pureAt(D.this)
					cm()  // ok: rcv is @pureAt(C.this)
				}
			}
		}
	}
Default @pureAt() member is taken from enclosing @pureAt():
class C {
	@pureAt(C.this) def m() = ???
	class D {
		def n() = ???  // default: @pureAt(C.this)
	}
}
Subtyping relations:
	@pureAt(D.this) <: @pureAt(C.this)  if D.this =:= C.this or @pureAt(D.this.outer) <: @pureAt(C.this)

When checking the receiver of a method:
- What do we have for the mutability of the class enclosing that method? A: the receiver mutability is already present.
- What do we have for the mutability of other enclosing-class references? A: ???
  The act of dereferencing, e.g., c.D, must have something to do with this.
  A new object is mutable on all enclosing classes. (Enclosing-ref mutabilities are protected by method receivers.)
  Arbitrary references can carry enclosing-class mutability information. (For checking against method rcv annots.)

Viewpoint Adaptation on Type Selection
	If c (of type C) is @readonly,
		then c.D is @pureAt[C].           // acceptable precision loss: enclosers of C are no longer mutable (although they may have been mutable in reference c)

In the example above,
	class C {
		class D {
			def dm1() = ???
			@pureAt[D] def dm2() = ???
		}
		@pure def cm(): D = {
			val d: D @pureAt[C] = new this.D   // this is @pureAt[C], so this.D is also @pureAt[C]
			d.dm1()  // Error: expected @mutable, got @pureAt[C]
			d.dm2()  // Ok: expected @pureAt[D], got @pureAt[C]. (@pureAt[C] <: @pureAt[D] because C contains D.)
			d
		}
		def cm2() = {
			val d: D @pureAt[C] = cm()
			d.dm1()  // Error: expected @mutable, got @pureAt[C]. (d's outer reference is @readonly, so an error here is to be expected.)
			(new this.D).dm1()  // but this is OK: this is @mutable, so "new this.D" is also @mutable.
		}
	}


<CHANGE-TO-DEFAULT-MUTABILITIES>
TODO:
1. Set default class-member mutability to __MUTABILITY__ >: mutable <: readonly
2. Refine class-reference types to { __MUTABILITY__ = mutable } if not already refined
2a. Refine Any to { __MUTABILITY__ =+ readonly }

Implemented default class members.

Test pos/rbtree is failing with errors like:
./tests/pos/rbtree.scala:66: error: type mismatch:
 found   : B1{__MUTABILITY__ =+ (dotty.mutable | B1#__MUTABILITY__)}(v)
 required: B
  def update[A: Ordering, B, B1 >: B](tree: Tree[A, B], k: A, v: B1, overwrite: Boolean): Tree[A, B1] = blacken(upd(tree, k, v, overwrite))
                                                                                                                             ^
Reverting default class members does not fix this error.
Attempting to revert further back.
(This is what I get for not consistently running all regression tests.)
DIAGNOSIS: A "fix" to the type comparer a few weeks ago is now causing problems. Fix discussion: <DISCUSSION: ABSTRACT-MUT-2>.
The problem is that the lower bound of B1 in rbtree is B, so the type comparer is taking mutabilityOf(B),
which does not compare identically to mutabilityOf(B1).
xxx POSSIBLE FIX: Now that default mutabilities are in place, I should be able to start removing special-case code in the type comparer.
MORE INFORMATION: Setting up a debug message where mutability defaults are causing false comparisons:
In the type comparer:
      if (((tp1 ne tp1defaulted) || (tp2 ne tp2defaulted)) && !super.isSubType(tp1defaulted, tp2defaulted) && super.isSubType(tp1, tp2))
        System.err.println(em"False comparison $tp1defaulted <: $tp2defaulted  (from $tp1 <: $tp2)")
Output debug messages:
	False comparison dotty.mutable | B1#__MUTABILITY__ <: dotty.mutable  (from dotty.mutable | B1#__MUTABILITY__ <: B1#__MUTABILITY__)
	... (error above) ...
	False comparison dotty.mutable | B1#__MUTABILITY__ <: dotty.mutable  (from dotty.mutable | B1#__MUTABILITY__ <: B#__MUTABILITY__)
	... (other errors) ...
What's clearly happening here is that tp2 (B1#__MUTABILITY__) is not observed to have a denotation,
and tp1 is not a simple-form mutability selection (tp1 is an OrType, not a TypeRef),
so tp2 is defaulted to its lower bound (mutable).
QUESTION: Shouldn't tp2 have a denotation now that class mutability member defaults are implemented in findMember?
INFO: The denotation computation involves a findMember on TypeVar(PolyParam(B)) or TypeVar(PolyParam(B1)).
	It is possible that, since B1 is uninstantiated, the ClassInfo defaulting is never reached,
	causing findMember to return a NoDenotation.
ANALYSIS: What's actually happening is the following:
  findMember on PolyParam(B).
  There is a constraint yielded for PolyParam(B), which is: TypeAlias(TypeRef(NoPrefix,B1),0).
  findMember on the denotation of TypeRef(NoPrefix,B1), which is the upper bound of TypeAlias(TypeRef(NoPrefix,B1),0).
  findMember on TypeBounds(TypeRef(NoPrefix,B), TypeRef(ThisType(TypeRef(NoPrefix,scala)),Any)).
  findMember on the denotation of TypeRef(ThisType(TypeRef(NoPrefix,scala)),Any).
  Possible exception?
No exception.
  What happens is that finding membership of a class denotation calls ClassDenotation#nonPrivateMembersNamed,
   which does not do the defaulting. Maybe I need to do the defaulting from ClassDenotation#findMember
    rather than Type#findMember.
  HOWEVER: Now rbtree has 129 errors (instead of 17 (instead of 0)).
Is there a better way to shadow/default mutability members?


<A CONVERSATION WITH ONDREJ>
On Tue, Nov 01, 2016 at 05:32:08PM +0000, Jonathan Rodriguez wrote:
> Hi Ondrej,

> I just wanted to let you know what Iâve been thinking about.

> We were looking at polymorphism and mutability, and whether my system could be simplified.
> One proposed approach is to encode polymorphic mutability as a type parameter:

>   def m[M >: mutable <: readonly]() â¦

> However, adding a mutability parameter may actually make the system unnecessarily complicated at some level.
> Hereâs my reasoning: The reason we proposed adding a type parameter M is to allow a mutability substitution
> to take place when the method is applied. However, even for parameterless methods, there is already a substitution
> that takes place: the âthisâ reference is substituted by the given receiver reference when the method is applied.
> (The substitution of âthisâ is actually a very fundamental operation in Dotty. It seems to be related to DOTâs
> self-reference substitution, which as far as I can tell, is the only kind of substitution required to implement DOT.)
> Ideally, I would want the receiver-mutability substitution to rely only on this-substitution, since it is
> specifically the mutability of âthisâ that we are trying to handle here. More specifically, the substitution of
> the mutability of âthisâ ought to be subsumable by the substitution of âthisâ itself wherever possible.

If I remember correctly, in ReIm, the viewpoint adaptation of @polyread
can be with respect to not the this parameter, but some other parameter.
That is, if you annotate this @mutable or @readonly and some other
parameter @polyread and the return type @polyread, then the return
type gets viewpoint-adapted according to the mutability of the
@polyread parameter, not the mutability of this.

That said, this seems like a rather unusual case, and I think it's fine
if your implementation of @polyread can only viewpoint adapt with
respect to the mutability of this.

> I now think that the problem is in how I was setting the default mutabilities.

> I am now looking into setting the mutability of named classes/traits to be abstract (rather than simply mutable). For example:

>   class C { type __MUTABILITY__ >: mutable <: readonly }

> That is, no class has a particular mutability. It is OK for the mutability to be abstract here since we will also
> assume that all objects will initialize the __MUTABILITY__ member to something during construction.
> (In the absence of other information, the only thing we know about an object of base class C is that its mutability
> is somewhere between mutable and readonly, which is exactly what we want when supporting polymorphism.)

Yes, this sounds reasonable.

> We are then left with the problem of properly defaulting the assignment to the __MUTABILITY__ memberâunannotated/legacy
> code assumes all objects are mutable. This assumption literally means that all objects (not classes) are initialized
> with the assignment âtype __MUTABILITY__ = mutable" unless otherwise annotated.

Yes, I think this is right.

> Here is the new set of defaulting rules that Iâm experimenting with:

> 1. All classes are assumed to contain the type declaration __MUTABILITY__ >: mutable <: readonly unless __MUTABILITY__
> is otherwise declared. Classes are only allowed to declare (not initialize) __MUTABILITY__.

> 2. All objects are assumed to initialize __MUTABILITY__ = mutable upon construction. However, this initialization
> may be overridden.

> 3. In practice, we assume that every non-singleton type expression contains âtype __MUTABLE__ = mutableâ unless
> otherwise annotated/initialized (this assumption is distinct from the assumption of the declaration of __MUTABLE__
> in classes). (Exception: the type expression âAnyâ is assumed to assign readonly. Defaulted & implicit type
> expressions are still considered type expressions.) (The widening of âthisâ produces a type with __MUTABILITY__
> initialized to something that depends on the current receiver-mutability annotation.)

OK, this sounds good. I'm looking forward to hearing about how it works out.

OndÅej

> - Jonathan


<RETURNING-AGAIN-TO-PURE-AT-MEANING>
@pureAt[p.D] means: The reference p.D.this widens to merely p.D (that is, no mutability refinement),
	and for every class q.C enclosing D, q.C.this widens to merely q.C (that is, no mutability refinement).
For classes r.E inside p.D, r.E.this is allowed to be mutable (unless otherwise annotated).
If @pureAt[p.D]'s context's immediately-enclosing class is D, then @pureAt[p.D] is equivalent to @pure.

Viewpoint adaptation:
  If p.c:C{__MUTABILITY__ = readonly} then c.D is assumed to refine { __PURE_AT__ = p.C }

	object p {
		class C {
			class D {
				def m = {
					val c1: p.C @readonly = ???
					val d1: c1.D = new c1.D
					d1.m2
				}
				// receiver for m2 assumes
				@pureAt[p.C] def m2 = ???
			}
		}
	}

Again:
	class Y {
		class X1 {
		}
		@pureAt[Y] class X2 {
			def m1() = ???
			@pureAt[Y] def m2() = { local_x = ??? }  // mutation inside X allowed, but not at Y or above.
			var local_x = ???
		}
	}
	val y: Y @readonly = ???
	new y.X2()  // error: cannot select X2 from path y: constructor X2.__init__ expects @mutable, got @pureAt[Y]
	val x: y.X2 @pureAt[Y] = new y.X2()  //
	x.m1()   // error
	x.m2()   // ok

x@pureAt[p.C] means that all references

Framing:
When a method m is called, m takes a receiver reference. In the Dotty language, the "receiver" is not just
a single reference, but a vector of references, one reference per enclosing class. When m is called, the
mutability of each element of this vector must be compatible with the corresponding receiver mutability
declared at m.

However, a "receiver vector" is still just a single reference. So this reference must encode the entire
mutability vector (or approximate it).

But we're not really talking about singleton types here. If we have a reference x of class C, and class D
encloses class C, then x's type must have some notion of what its mutability is wrt. D (mutability wrt. C
is already handled by the existing mutability system). Generalizing, if we have an arbitrary type X that
has C as a base class, then X must have some notion of what its mutability is wrt. D. Of course, X may
have many base classes _C, with just as many enclosing classes _D. We don't know which _D will be the actual
enclosing class at runtime, so the system here must deal with all possible _D.

One way to handle this issue is to invent a type mechanism to say, "X is mutable up to classes [_D1,..,_Dn]."
(Reim has a simpler binary version of this: every method has a receiver mutability and a static mutability.
I propose to extend this mechanism to include enclosing classes.)
What a type must include to implement this mechanism is a set of classes. Can this set be implemented as
an intersection type? (Yes.)

Proposed special members:
  __MUTABILITY__ - basic receiver mutability.
  __MUTABLE_UP_TO__ -
    Allowed types:
      Top: Any
      Intersection: p1.D1 & .. & pn.Dn
      Bottom: Nothing
Intersection is an arbitrary type whose base classes constitute the boundaries within which the reference is allowed to be mutable.
Any means that the reference is allowed to be mutable everywhere (up to root/static scope).
Nothing means that the reference cannot mutate any enclosing scope.
If G.this is requested for some outer class G, and G is or is inside a class E where Intersection contains E or a
 superclass of E, then G.this is allowed to be considered mutable. G.this is also allowed to be mutable if __MUTABLE_UP_TO__ is Any.
If __MUTABLE_UP_TO__ is not present, it is defaulted to Any where __MUTABILITY__ is (or is defaulted to) mutable,
  and Nothing where __MUTABILITY__ is (or is defaulted to) something other than mutable.

Is there a way to reuse subtyping relationships to expedite progress?
Where a type contains the type initialization "__MUTABLE_UP_TO__ = X", class p.G is a local boundary if p.G.this.type <: X.

Receiver Example:
class E {
	class D {
		class C {
			/* __READONLY_REFS__ =+ root.E.this */ def m() = {
			}
			/* __READONLY_REFS__ =+ root.E.this.D.this.C.this */ def m2() = {   // default from "@readonly def m2"
			}
			/* __READONLY_REFS__ =+ root.E.this.D.this */ def m3() = {  // two readonly references in environment
			}

			/* __MUTABLE_OUTERS__ =+ root.E.this.D.this */ def m4() = {  // mutable D.this, E.this is polyread
			}
			/* __MUTABLE_OUTERS__ =+ root & root.E.this.D.this */ def m5() = {  // mutable in static root and D.this
			}
			/* __MUTABLE_OUTERS__ =+ root & root.E.this & root.E.this.D.this */ def m6() = {  // mutable in root, E.this, and D.this
			}
		}
	}
}
//val d: e.D @outer[root.E{__MUTABILITY__=+readonly}] = new e.D()  // d is mutable, but with a boundary: e.type.widen is root.E @readonly.
//       // note: root.E.this gets replaced by e inside D here
//val c: d.C @outer[root.E{__MUTABILITY__=+readonly}] = new d.C()  // viewpoint adaptation copies boundary without change: d is mutable.
//       // note: e.D.this gets replaced by d inside C here
//c.m()  // why is this OK?

val e: root.E @readonly /* __READONLY_REFS__ =+ ??? */ = ???
val d: e.D /* __READONLY_REFS__ =+ e */ = ???
       // note: root.E.this gets replaced by e inside D here
val c: d.C /* __READONLY_REFS__ =+ e */ = ???  //
       // note: e.D.this gets replaced by d inside C here
c.m()  // ok: c and m's receiver sig. both have "__READONLY_REFS__ =+ e"

val e: root.E @readonly /* __MUTABLE_OUTERS__ =+ root */ = ???
val d: e.D /* __MUTABLE_OUTERS__ =+ root */ = ???      // e isn't mutable, so it doesn't get added to the mutable-outers list
       // note: root.E.this gets replaced by e inside D here
val c: d.C /* __MUTABLE_OUTERS__ =+ root & d */ = ???  // d is mutable, so it gets added to the list
       // note: e.D.this gets replaced by d inside C here
c.m5()  // OK: c and m's sig. both have "__MUTABLE_OUTERS__ =+ root & d"
c.m6()  // error: root & d is not compatible with root & e & d

Possible implementation plan:
xxx 1. Viewpoint adaptation: type selections: p.T: (can't refine p.T, otherwise dotc will complain that "new p.T" isn't a class).
yyy 1. Mutable-outer queries: mutableOuter(p.T) returns mutableOuter(p.type.widen) if p is non-mutable,
yyy	    mutableOuter(p.type.widen) & p.type if p is mutable,
yyy 	Any if p is root.
zzz1. Viewpoint adaptation redeux: we actually do type refinements when info is requested on p.T (avoiding the problem above).
zzz 	???
Recontextualization:
(it seems that
...


Can an overridden method call its super? (Yes.)

(Example of subclassing with mutable outers)
class E {
	class C {
		/* __MUTABLE_OUTERS__ =+ root.E */ def m() = ???
	}
}
val e: root.E = ???
class D extends e.C {
	/*  */ override def m() = {
		// Note no __MUTABLE_OUTERS__ on overriding m. We don't check overrides here. (See [1] below.)

		super.m();  // or: root.D.super[e.C].m()
		// root.D.super is mediated through root.D.this
		// The reference e.C must be equivalent to e.C{ __MUTABLE_OUTERS__ =+ e }
		// so super[e.C] must widen to e.C{ __MUTABLE_OUTERS__ =+ e }
	}
}
// The "outer" reference of super.m is actually e; the prefix of e.C.
// So the mutability of e matters; if e widens to root.E@readonly, then super[e.C].m could not be called from D.this.m.

// [1] Actually, the __MUTABLE_OUTERS__ = root on m. D's base class is root.e.C.
// So __MUTABLE_OUTERS__ on C.m has root & root.E.this, and D.m has just root.
//  We have the subtyping relationship:  root & root.E.this  <:  root
//  Method receivers are contravariant, so the override of m checks out OK.

It seems that I'm not really looking for a type-annotation-style mechanism here.

Proposal: Each method is associated with a set of @polyread outer references.
	When the method is called, every non-mutable reference in the receiver's stable prefix must exist in this set.
Flipping the system: each method is associated with a set of mutable outer references. (Every outer reference not in this set is considered @polyread.)
	When the method is called, every mutable reference in the receiver's stable prefix must exist in this set.
	(The advantage of the flipped system is that the receiver's outer-reference discovery and checking are more thoroughly tested.)

Q: What is the "root" reference defined to be? A: defn.RootPackage. Its type (info) is TypeRef(NoPrefix, RootClass).
Info: The owner of top-level terms is RootClass. The owner of top-level types is EmptyClass. (from Denotations#staticRef).
	The basic structure seems to be the following:
	class RootClass {
		object scala { ... }
		object java { ... }
		object dotty { ... }
		object <empty> { ... }  // this object contains code that is not part of any other package
		object <special-ops> { ... }
	}
	val RootPackage: RootClass = ...

Other items:
1. Do automatic refinement of ValDef/DefDef result types: If the rhs is non-mutable, and the lhs result type is
   mutable (but does not have a mutability refinement), then refine it to the rhs mutability.

Defining boundary testing in terms of subtyping instead of subclassing prevents fragility problems.

Plan:
	1. Implement outer-reference mutability discovery for methods. (step A: return a list of references. step B: reduce the list as method annotations are parsed.)
	2. Implement prefix-mutability discovery.
	3. Implement check for prefix/outer-mutability compatibility.

AFTER 2 ATTEMPTS AT PREFIX/OUTER MUTABILITY CHECKING:
There is a basic issue where inheritance causes prefix types to not match outer-reference types. For example, in building core.Symbols,
the code structure is the following (simplified for readability):

	object core {
		object Symbols {
			def synthesizeCompanionMethod(..., owner: SymDenotation ...) =
                if (owner.exists ...) ...   // calling "exists" from prefix "owner"
		}
		object SymDenotations {
			class SymDenotation extends Denotation {  // the class of "owner" is here
			}
		}
		object Denotations {
			class Denotation {
				def exists: Boolean = ...  // "exists" exists here
			}
		}
	}

If I modify "def exists" to "@pureAt[Denotations] def exists", I have a problem:
The module "Denotations" does not exist in the prefix path of "owner".
What I find instead in the prefix of "owner" is SymDenotations, since "owner" is a SymDenotation.

Alternative solution: Use "@mutableTo[Denotation]" instead of "@pureAt[Denotations]".

Checking: The highest-level mutable class in the outers chain must be inside some mutable
class in the receiver-prefix chain. (It suffices to say that the highest-level mutable symbol
in the outers chain must be inside the highest-level mutable symbol in the prefix chain.)