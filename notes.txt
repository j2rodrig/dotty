NOTES

	Initial Comments on the TryThree branch:
    // Trying not to repeat code:
    // alt1: report shadow members directly from findMember. but then, how should we do type comparison?
    // alt2: instead of shadow members, use shadow base types. Treat bases as intersected types.
    //    but how to express lack of mutability?--perhaps a type member in a refinement of the shadow base?
    // Again here we run into the problem of expressing a lack of mutability given an underlying
    // type that has mutability. This seems like a situation where we would want to do an override
    // if the underlying type already contains that type member. Overrides are OK--I think I can
    // live with overrides.

    /*
    ATTEMPT 1: FAILED: A RefinedType is not always accepted where a TermRef is accepted.
      One failure instance: in realApply in Applications: methPart(fun1).tpe is expected to be a TermRef.
        The problem here seems to be that the underlying type is a method rather than a reference,
        so one way to fix this is to check that we've actually got a reference type underlying.
      Update: as it turns out, just checking for a non-methodic type is not enough. Also, checking for a stable TermRef is not enough.
      An alternative is to do adaptations only on certain kinds of trees, but this could get ugly.

    val MutabilityMember = typeName("$$$$_mutability!$$$$")

    // For TermRefs: viewpoint-adapt the prefix.
    def adaptTermRef(tpe: TermRef)(implicit ctx: Context): Type = {
      val prefix = tpe.prefix
      prefix.findMember(MutabilityMember, prefix.widenIfUnstable, EmptyFlags) match {
        case NoDenotation => RefinedType(tpe, MutabilityMember, defn.NothingType)
        case denot: SingleDenotation => RefinedType(tpe, MutabilityMember, denot.info)
      }
    }

    // For ThisTypes: viewpoint-adapt based on enclosing-scope annotations.
    def adaptThisType(tpe: ThisType): Type = {
      tpe
    }

    def adaptAnnotatedType(tpe: AnnotatedType)(implicit ctx: Context): Type = {
      if (tpe.annot.symbol eq defn.ReadonlyAnnot)
        RefinedType(tpe.underlying, MutabilityMember, TypeBounds(defn.NothingType, defn.AnyType))
      else
        tpe.derivedAnnotatedType(adaptType(tpe), tpe.annot)
    }

    def adaptType(tpe: Type)(implicit ctx: Context): Type = tpe match {
      case tpe: AnnotatedType => adaptAnnotatedType(tpe)
      case tpe: TermRef => adaptTermRef(tpe)
      case tpe: ThisType => tpe
      case _ => tpe
    }

    override def adapt(tree0: tpd.Tree, pt: Type, original: untpd.Tree)(implicit ctx: Context): tpd.Tree = {

      // Find out what type the default typer thinks this tree has.
      val tree = super.adapt(tree0, pt, original)
      val tpe = tree.tpe

      // Do our stuff to the type.
      val tpe1 = adaptType(tpe)

      // TODO: extra type check?

      //if (tpe1 eq tree.tpe) tree
      //else {
      //  val tree1 = tree.withType(tpe1)
      //  if ((ctx.mode is Mode.Pattern) || tpe1 <:< pt) tree1
      //  else err.typeMismatch(tree1, pt)
      //}

      /*val dontCheck = (
        pt == WildcardType
          || !tree1.tpe.exists
          || pt.isInstanceOf[ProtoType]
          // || tree1.tpe <:< defn.AnyValType   // classes may extend AnyVal, so we do have to check
        )

      if(dontCheck) tree1 else {
        // TODO check that tree.tpe <:< pt wrt. mutability
        tree1
      }*/

      if (tpe ne tpe1) tree.withType(tpe1) else tree
    }*/


    /*
    ATTEMPT 2: FAILED.
    Using "shadow members" as separate things from normal members is obviously complicated,
    as it would involve replicating (at a minimum) the implementations of findMember and isSubType.

    However, using adaptApplyResult as a hook into realApply seems like a very good way to extensibly
    handle viewpoint adaptation. In realApply, we have access to the receiver, the result, the
    method denotation, and all arguments.


    def mergeShadowMutabilities(pre: Type, inf: Type)(implicit ctx: Context): Type = OrType(pre, inf)

    // For TermRefs: viewpoint-adapt the prefix.
    def adaptTermRef(tpe: TermRef)(implicit ctx: Context): Type = {
      val prefix = tpe.prefix
      val prefixMember = prefix.findShadowMember(MutabilityMember, NoPrefix)  //, tpe.widenIfUnstable)
      if (prefixMember ne NoType) {
        val unadaptedMember = tpe.findShadowMember(MutabilityMember, NoPrefix)  //, tpe.widenIfUnstable)
        val adaptedMember =
          if (unadaptedMember eq NoType)
            prefixMember
          else
            mergeShadowMutabilities(prefixMember, unadaptedMember)
        tpe.setShadowMember(MutabilityMember, adaptedMember)
      }
      tpe
    }

    // For ThisTypes: viewpoint-adapt based on enclosing-scope annotations.
    def adaptThisType(tpe: ThisType): Type = {
      tpe
    }

    def adaptAnnotatedType(tpe: AnnotatedType)(implicit ctx: Context): Type = {
      if (tpe.annot.symbol eq defn.ReadonlyAnnot) {
        tpe.setShadowMember(MutabilityMember, defn.AnyType)
        //RefinedType(tpe.underlying, MutabilityMember, TypeBounds(defn.NothingType, defn.AnyType))
        tpe
      }
      else
        tpe.derivedAnnotatedType(adaptType(tpe), tpe.annot)
    }

    def adaptType(tpe: Type)(implicit ctx: Context): Type = tpe match {
      case tpe: AnnotatedType => adaptAnnotatedType(tpe)
      case tpe: TermRef if tpe.isStable => adaptTermRef(tpe)
      case tpe: ThisType => tpe
      case _ => tpe
    }

    override def adaptApplyResult(funRef: TermRef, res: Tree)(implicit ctx: Context): Tree = {
      println(s"Apply type = ${res.tpe}")
      println(s"Fun type = ${funRef}")
      val receiver = funRef.prefix
      val methodDefs = funRef.alternatives
      if (funRef.findShadowMember(MutabilityMember, NoPrefix) ne NoType)
        println(funRef.findShadowMember(MutabilityMember, NoPrefix))
      res.tpe.copyShadowMembers(funRef)
      res
    }

    override def adapt(tree0: tpd.Tree, pt: Type, original: untpd.Tree)(implicit ctx: Context): tpd.Tree = {
      // Find out what type the default typer thinks this tree has.
      val tree = super.adapt(tree0, pt, original)
      val tpe = tree.tpe

      //if (tree.isInstanceOf[tpd.Apply]) println(s"Apply type = $tpe")

      // Do our stuff to the type.
      val tpe1 = adaptType(tpe)

      // Return a tree with the new type.
      if (tpe ne tpe1) tree.withType(tpe1) else tree
    }
   */


    /*
      ATTEMPT 3 partial failure - Putting shadow member checking directly inside the type comparer
       is causing the statement "val c: C @readonly = new C" to interpret the RHS type as Object.
      This is probably due to the constraint solver being unable to find a type T where
       C <: T <: C @readonly. (But this doesn't make sense to me--it should be able to select
       either C or C @readonly and be OK.)

      One possible course of action here is to see where the constraint solver checks subtypes
       and try to figure out why it does this.

      A second course of action is to create a secondary type comparer in the DotMod extension
       and invoke it only when checking certain kinds of trees (e.g., assignment).

      Let's try both.

      New information: The statement above fails even if the custom addition to the type comparer
      is disabled. Perhaps the AnnotatedType itself is causing a problem?
      New information: Stripping the annotations doesn't change the result. Perhaps there is
      something wrong with findMember? (which is the only other place where significant changes have been made?)
      New information: Disabling the shadow-member early-exit in findMember makes the error disappear.
      New information: The shadow-member early exit is taken if the requested member is from Object
        (e.g., method <init>), since Object is the refinement parent of the shadow bases.
        Now trying to filter these requests so we don't get members of Object.

      SUCCESS: Filtering out members of Object in findMember's shadow-member logic seems to work.
        Now making annotation stripping optional.
    */


    /*
      ATTEMPT 3b partial failure - Passing the assignment "val e: C = d" where d is C @readonly.

      It is possible that I got the shadow-member check in the type comparer wrong...

      For tp1 <: tp2, if the shadow member exists only in tp2, then t1 is assumed to have the member == Nothing, which should always succeed.
      This is implemented.
      If the shadow member exists only in tp1, then t2 is assumed to have the member == Nothing, which should fail unless t1's member is also Nothing.
      This is not implemented.

      New information: The type comparer is updated to fix this problem, but there is no change in output.

      There is possibly something wrong with the representation of readonly:
      The current implementation uses isSubType to compare RefinedType bases, but maybe this won't give the correct
      result if we want two readonly types to compare equal... possibly, shadow member types should be manipulated
      directly rather than encased inside RefinedTypes.

      What we're after here must have the following relations:
        Readonly <: Readonly
        Untyped <: Readonly
        Untyped <: Untyped
      This is really only a single bit.

      As for polymorphism, we want to compare with an arbitrary type, but only wrt to readonlyness.
      Thus, type members.
      So we're back to comparing shadow types directly, rather than as refined members.
      (The problem with using RefinedTypes to hold these members is that I am skeptical that:
        Object { M <: Any }  <:  Object { M <: Any }
        ).
      So, findMember should still return the requested member early-exit (to get the shadowing effect),
      but I should do the following:
        - return the refinedInfo directly, rather than doing a findMember on the shadow base.
        - make the refinedInfo for Readonly have the property Readonly <: Readonly.
        - choose Nothing as the default refinedInfo. (to get Untyped <: Readonly and Untyped <: Untyped)

      New information: In trying to compare defn.NothingTyoe <: TypeBounds(...), isSubType returns false.
        defn.NothingType is a TypeRef rather than a ClassInfo, which doesn't seem to compare correctly.

      A possibility is to make both halves into covariant TypeBounds.

      SUCCESS: now Untyped <: Readonly returns true as expected.
      New FAILURE: There's now a failure in ReTyper#typedSelect where "new C" is reported
        incompatible with its prototype.
        The specific phase reporting the problem is "Ycheck".
      One option here is to temporarily disable phases after the typer, and deal with
        this issue later (if necessary).

      FAILURE: Still not getting an error on "val e: C = d" after disabling Ycheck options.
        It looks like there is an issue with the fact that I'm not duplicating types before
        setting their shadow members. Since I have "C @readonly" at a prior line, the TypeRef
        to C gets a shadow member, so the use of this TypeRef on the next line is interpreted
        as Readonly. The duplication is probably unnecessary for singleton types (since the
        singleton type means the same type everywhere), but duplication couldn't hurt.

      (Note: shadow members are now copied in Type#newLikeThis.)

      Still not getting the expected failure. The TypeRef to C is still getting a shadow member added.

      New theory: the call to ctx.uniqueNamedTypes.enterIfNew (which is invoked when I try to duplicate
      named types) is not returning a new Type object, but rather is returning the old object because
      the name and prefix are equivalent to the old Type object.
      One option: Attempt to add a flag that adds the new type regardless of prior cached objects.
      A second option: Create and add the object directly in duplicate method, using ctx.uniqueNamedTypes.enterIfNew as an example.

      FAILURE: Still no effect. The TermRef referring to d isn't reporting any shadow members.
      Possibly, changing tree types is not enough. We need to get the shadow types into the symbol info.
      Possibly: Change types in the symbol completer?
      New information: The underlying symbol info for "d" is in fact the correct type.
      The TermRef's prefix is the module type, so it (correctly) is not reporting any shadow members.

      New information: The type comparer calls baseTypeRef when tp2 refers to a class symbol.
      baseTypeRef (correctly) returns a reference to the class, but (incorrectly) fails to
      copy shadow members of the class. One way to fix this is to add a check for shadow members in
      this particular case block. But perhaps a better way is to modify the shadow member comparison
      to call findMember instead of merely doing a surface-level check on both types.

      Another possibility is to extend the type comparer. This way, we already know the name of the
      specific member we're searching for.

      SUCCESS: A type mismatch error is generated for "val e: C = d".
      ./tests/dotmod/viewpoint1.scala:7: error: type mismatch:
       found   : viewpoint1.C @readonly(viewpoint1.d)
       required: viewpoint1.C
        val e: C = d
                   ^
     */

	SUCCESS on the Dotty update.
	SUCCESS on a few of the standard tests.

	PROBLEM: Somehow, we're getting an ErrorType inside the mutability member info.
		During the neg_autoTupling test.
	New information: We're getting a type alias to ErrorType when looking up the mutability member
	  during viewpoint adaptation. Where are these mutability members being generated?
	  It seems that it is possible for a TermRef prefix to be an ErrorType, which
	  will return an alias to ErrorType if a type-member query is performed.
	SUCCESS: neg_autoTupling test is now reporting the correct number of errors.

	PROBLEM: pos_autoTupling is generating 1 error where 0 are expected.
	SUCCESS: The error was being generated on pattern matching. Solution was to make sure
	  type compatibility checks do not happen in Pattern mode.

	SUCCESS: Passes all 662 positive Dotty tests.


ISSUE CYCLE-1:

	ERROR: in tests/neg/cycles.scala. Stack overflow after line 19 involving findMember.

	New information: The cycle seems to be when looking for the mutability member
	inside type member T inside class B. (Although previous evidence indicates that
	the cycle causing the stack overflow is actually inside class C or D, searching
	for a solution to the cycle in class B may solve the problem.)

	New information: The actual cycle is looking for the mutability member inside T
	with prefix E.x. The specific line triggering the cycle is:
	"val denotTpe = tpe.member(MutabilityMember)" where tpe is a TermRef
	representing the selection "E.this.x", which is widened to "E.this.F#T",
	which has the bounds Nothing .. E.this.x.
	The difficult part of this cycle is that it occurs entirely within the
	original Dotty code (Types#findMember -> go(this) -> Denotations#findMember) --
	all DotMod tries to do is call findMember at an (apparently) unusual time.

	Actual code in example:
	class E {
      class F {
        type T <: x.type // old-error: not stable
        val z: x.type = ??? // old-error: not stable
      }
      lazy val x: F#T = ???
    }
	What is "old-error"? If x is eager rather than lazy, then Dotty triggers
	"error: cyclic reference involving value x".
	One option is to simply ignore this test case for now.
	 The facts that may make ignoring acceptable are:
	 - The type-projection operation # is known to cause type-correctness failures,
	   and it may be removed in future versions of Dotty.
	Another option is to try to determine whether there is:
	- a bug in findMember
	- a valid reason to disallow calling findMember in such cases
	  (and what defines "such cases" anyway?)

	Does findMember make sense for arbitrary type projections?

	New information: If I change the order of the lazy val to the following, everything works OK:
	class E {
      lazy val x: F#T = ???
      class F {
        type T <: x.type // error: cyclic reference involving lazy value x
        val z: x.type = ???
      }
    }

	Looks like a Dotty bug.

	SUCCESS: With the definition ordering in tests/neg/cycles.scala changed, all negative tests pass.

MUTABILITY EXTRACTION

	Is it possible to declare the mutability of one type to be the same as another type?

	val foo: Foo { type +$M = readonly }
	val bar: Bar { type +$M = foo.$M }

	Annotations:
	val foo: Foo @readonly
	val bar: Bar @mutabilityOf(foo)

	The type of bar is given a shadow member that is a TypeRef to the shadow member of foo, or:
	  TypeRef(TermRef(NoPrefix, foo), $M)

	Defining annotation:
		class mutabilityOf(val ref: Any @readonly) extends scala.annotation.Annotation
	The parameter "ref" is the term to extract mutability from.
	It is @readonly so that it can take an argument of any mutability.
	PROBLEM: Since the definition of mutabilityOf is loaded from a classfile, the current DotMod is not
	processing the @readonly on the ref parameter.

	One possible solution is to do annotation processing during lazy symbol completion.
	However, it is currently unclear how to make a clean compiler extension using this mechanism.
	Let's try it anyway.
	New information: The completer in SymDenotation is not getting called. How are we getting the type of "ref"?
	Let's see what the typer is actually doing with the "ref" parameter.
	New information: The mutability extraction/attachment is not even complete yet.
	I should finish this before trying to debug the last problem.

	Partial SUCCESS: The following test:
	  class C
	  val c: C @readonly = ???
	  val d: C @mutabilityOf(c) = c  // ok
	  val e: C = d  // error

	Reports the following errors:
	./tests/dotmod/neg/mutability_of.scala:7: error: type mismatch:
	 found   : mutability_of.C @readonly(mutability_of.c)
	 required: Any
	  val d: C @mutabilityOf(c) = c  // ok
	                         ^
	./tests/dotmod/neg/mutability_of.scala:8: error: type mismatch:
	 found   : mutability_of.C @mutabilityOf(mutability_of.d)
	 required: mutability_of.C
	  val e: C = d  // error

	Where is the definition of mutabilityOf getting typed?

	Definition is loaded by: requiredClass("dotty.mutabilityOfRef").typeRef
	Def. of requiredClass: base.staticRef(path.toTypeName).requiredSymbol(_.isClass).asClass
	Def. of typeRef: TypeRef(owner.thisType, name.asTypeName, this)

	New information: The @readonly part of the Any param type doesn't seem to be part of the mutabilityOf
	constructor signature at all. Perhaps it's not getting put into the classfile to begin with?
	Making the readonly class inherit from ClassfileAnnotation... no effect.

	Perhaps there's another route to getting mutability to appear in classfiles?
	A possibility: Representing shadow members as real type refinements (that wrap type expressions).
	Would there need to be some logic to set the "override" flag on refined members?

	FAILURE: Tried a refinement type in mutabilityOf:
		class mutabilityOf(val ref: Any { type $M$ <: readonly } ) extends scala.annotation.Annotation
	Same symptom is occurring -- it seems that "Any { type $M$ <: readonly }" is being interpreted as
	merely "Any" during the check. This is actually a symptom of a bigger issue: in general, for:
		val foo: Any { type _m = readonly }
		val bar: Any { type _m = readonly }
	foo is not compatible with bar. This is surprising because according to DOT, this should work.
	CORRECTION:
	The mutability-member name I was using contained the unicode symbol ɱ (code point 0x0271).
	Changed to an all-ASCII name, it works as expected. (weird bug).
	New information:
	The failure above is due to:
	1. Matching refinement members removed in TypeComparer on line:
		val skipped2 = skipMatching(tp1w, tp2)
	2. The DotMod type comparer extension finding a shadow member inside tp1w, but not tp2.

	One option is to do the mutability check at the top level only (e.g., in topLevelSubType, not isSubType).
	This option would be OK if we do not need to consider type member compatibility in subtype checks (which we do).
	Another option is to attempt the bigger problem of shadow members (see below).

	Another issue:
	Ondrej and I seem to be in agreement that the adaptation of TermRefs (and singleton types in general)
	should not be viewpoint-adapted.
	The interpretation of shadow members on singleton types is really that the underlying (widened)
	types have those members.
	The idea here is that shadow members become real members when they are widened to TypeRefs.

DISCUSSION OF REALIZATION OF SHADOW MEMBERS: What Shadow Members Mean

	Examples:

	C.this.type  -- is a singleton type

	C @readonly  -- becomes:
	C { type __MUTABILITY__ <: readonly }

	Given:
	val c: C @readonly
	c.x  -- has type: c.x.type { type +$M$ = c.$M$ }

	The following types can be wrapped in RefinedTypes:
	 TypeRef
	 RefinedType / RecType
	 AndType / OrType
	 PolyType? / TypeLambda?
	The following types cannot be wrapped directly, but should have their underlying types wrapped appropriately:
	 TermRef
	 ThisType? / SuperType?
	 SingletonType?


	One of the problems with refinement is that:
		{ type _M = Nothing } { type _M <: readonly } is compatible with { type _M = Nothing },
	which means that once we decide to add a member that declares a type to be Mutable,
	we can't arbitrarily override it.
	However: If we set the latter mutability to be equal:
		{ type _M = Nothing } { type _M = readonly }
	then the last (outermost) mutability seems to override the previous mutability.
	The handling of TypeAliases seems to behave a little differently than mere TypeBounds;
	  if we just set the latter bounds without an alias:
		{ type _M = Nothing } { type _M >: readonly <: readonly }
	  then _M is interpreted to be Nothing rather than readonly.
	Covariance should allow the desired subtyping relationship: { type _M = Nothing } <: { type _M = readonly }.

	Avoiding false negatives:
	Considering a type T without the member _M, we have:
		T { type _M = readonly } <: T
	which is incorrect.
	Probably what we should check for during subtyping is: If the lesser type is a refinement of member _M,
	and the greater type does not define member _M, then we force return false if the lesser type's version
	of _M isn't Nothing. (We should do this check in isSubType before calling super.isSubType for the best performance.)

	Widening and type refinements:
	A big issue that I have to solve here is how to deal with widenings (which need to be viewpoint-adapted).
	The current solution is to handle widenings by using shadow members on TermRefs.
	This is no longer the current solution. It should be possible to perform viewpoint adaptation without shadow members.

	Where viewpoint adaptation happens:
	Currently, the place where viewpoint happens is when the underlying type of a NamedType is taken.

	Where annotations can occur:
	Pursuant to email conversation with Ondrej, annotating singleton types doesn't make sense (since a
	singleton type contains, by definition, exactly one type). The criterion for annotation is the
	same as the criterion for refinability: if the type can be refined, then we allow an RI annotation
	to be placed on that type.
	The following can be annotated:
	- TypeRef
	- PolyParam
	- RefinedType / RecType
	- HKApply
	- TypeVar ?
	- AndType / OrType
	- AnnotatedType
	Some types cannot be annotated directly, but their underlying types participate in viewpoint adaptation.
	The following cannot be annotated, but they can be the target of a viewpoint adaptation:
	- ExprType
	- TypeAlias / TypeBounds
	- TypeLambda
	- WildcardType

	SUCCESS: in doing basic viewpoint adaptation with type refinements rather than shadow members.
	Deprecated code (for adding & viewpoint adapting shadow members):
	/*
    /**
      * If tpe is an annotated type, finds the meaning of RI annotations.
      * If there is a meaningful RI annotation, sets the first non-annotation underlying type's
      * shadow member.
      *
      * Returns a version of the type that has shadow members, but is stripped of all RI annotations.
      */
    def toShadows(tpe: Type, shadowInfo: Type)(implicit ctx: Context): Type = tpe match {
      case tpe: AnnotatedType =>
        if (tpe.annot.symbol eq defn.ReadonlyAnnot)
          tpe.derivedAnnotatedType(toShadows(tpe.underlying, ReadonlyType), tpe.annot)  // leave RI annotations in place (for now)
        else if (tpe.annot.symbol eq defn.MutabilityOfAnnot) {
          val argTpe = typed(tpe.annot.arguments.head).tpe
          val newShadowInfo = argTpe.member(MutabilityMemberName).info
          tpe.derivedAnnotatedType(toShadows(tpe.underlying, newShadowInfo), tpe.annot)  // leave RI annotations in place (for now)
        } else
          tpe.derivedAnnotatedType(toShadows(tpe.underlying, shadowInfo), tpe.annot)  // leave non-RI annotations in place
      case _ =>
        if (shadowInfo.exists)
          tpe.duplicate.addUniqueShadowMember(MutabilityMemberName, shadowInfo, visibleInMemberNames = true)
        else
          tpe
    }

    def adaptType(tpe: Type)(implicit ctx: Context): Type = tpe match {

      case tpe: AnnotatedType =>
        toShadows(tpe, NoType)

      case tpe: TermRef =>
        if (tpe.prefix.isError)
          tpe
        else {
          // Check the prefix: We need to change the mutability of tpe only if tpe.prefix has a mutability member.
          val denotPrefix = tpe.prefix.member(MutabilityMemberName)
          if (denotPrefix.exists) {
            val infoCombined = {
              val denotTpe = tpe.member(MutabilityMemberName)
              if (denotTpe.exists) {
                // if prefix and tpe both have the shadow, combine their types with a union.
                val info1 = denotPrefix.info.asInstanceOf[TypeAlias].hi  // assume we've got type aliases here
                val info2 = denotTpe.info.asInstanceOf[TypeAlias].hi
                TypeAlias(OrType(info1, info2), 1)
              } else
                denotPrefix.info // only the prefix has a shadow
            }
            tpe.duplicate.addUniqueShadowMember(MutabilityMemberName, infoCombined, visibleInMemberNames = true)
          } else
            tpe
        }

      case _ =>
        tpe
    }
	*/

	FAILURE: Involving @mutabiliyOf.
	Test input:
	  class C
	  val c: C @readonly = ???
	  val d: C @mutabilityOf(c) = c  // ok
	  val e: C = d  // error
	Output:
	./tests/dotmod/neg/mutability_of.scala:7: error: type mismatch:
	 found   : mutability_of.C{__MUTABILITY__ =+ dotty.readonly}(mutability_of.c)
	 required: AnyRef{__MUTABILITY__ <: dotty.readonly}
	  val d: C @mutabilityOf(c) = c  // ok
	                         ^
	./tests/dotmod/neg/mutability_of.scala:7: error: type mismatch:
	 found   : mutability_of.C{__MUTABILITY__ =+ dotty.readonly}(mutability_of.c)
	 required: mutability_of.C{__MUTABILITY__ =+ mutability_of.c.__MUTABILITY__}
	  val d: C @mutabilityOf(c) = c  // ok
	                              ^
	./tests/dotmod/neg/mutability_of.scala:8: error: type mismatch:
	 found   : mutability_of.C{__MUTABILITY__ =+ mutability_of.c.__MUTABILITY__}(mutability_of.d)
	 required: mutability_of.C
	  val e: C = d  // error
	             ^
	SUCCESS:
	Needed to add special cases to the type comparer to handle refinements of the mutability member.
	In particular, when comparing tp1 <: tp2 where tp1 has a mutability member but tp2 does not,
	 ordinary subtyping logic simply ignores the member on tp1. What makes this a problem is that
	 if tp1 is not a RefinedType, but widens to a RefinedType, then the ordinary type comparer
	 will widen and then discard the refined type member without calling into the custom type comparer.
	 What we do now is take over the subtype comparison where tp1 widens to a RefinedType that
	 contains the mutability member. We do a findMember on tp2, compare the result with the widened tp1's
	 mutability member, then continue the subtype comparison on tp1's parent and tp2 (or tp2's parent
	 if tp2 is a refinement of the mutability member).
	The opposite case, where tp2 is a refinement of the mutability member but tp1 does not contain
	 the mutability member, is handled more simply. The default mutability is the bottom type mutable,
	 so we need only to check whether tp1 is compatible with tp2's parent.

	NOTE on viewpoint adaptation:
	For a denotation selection to be viewpoint adapted, two conditions must be met:
	- the selected denotation must be a term (not a type).
	- the type of the selected denotation must be an annotatable non-singleton type,
	 or a proxy for such a type.

	Revisiting the list of acceptable types for viewpoint adaptation:
	Types we should be able to refine:
	 - TypeRef
	 - RefinedType / RecType
	 - AndType / OrType
	 - PolyParam
	 - TypeVar
	 - HKApply
	Types where the underlying type may be refineable:
	 - AnnotatedType
	 - ExprType       -- viewpoint adaptation of result is needed so that arbitrary widenings produce a viewpoint-adapted result
	 - TypeLambda
	 - WildcardType   -- viewpoint adaptation may change the upper bound of the WildcardType.

	Question: does every non-overloaded denotation have a valid symbol?
	Answer: no, but we don't care--we're only looking at the type of the denotation, not its symbol.

ASSIGNABILITY

	What we're doing for assignability is to introduce a second type member that contains the mutability
	of the prefix type. There are now two type members we're using:
		__MUTABILITY__   -- the mutability of the type
		__PREFIX_MUTABILITY__   -- the mutability of the prefix type (if the type is viewpoint-adapted)
	The check for assignability is rather simple: If the info of the __PREFIX_MUTABILITY__ member is
	a subtype of mutable, then the type is assignable. Otherwise, it is not assignable.

	Implications for type comparison:
	If tp1 is a RefinedType, it is no longer sufficient to to just look at tp1's refinedInfo;
	the refinement no longer necessarily refers to the mutability member.
	Instead, it does a findMember on tp1 to capture any underlying refinements of the mutability member.

	Furthermore, if tp2 is a refinement of the prefix mutability, then subtyping unconditionally proceeds
	to tp2's parent type. The net effect is that the prefix mutability member itself has no effect
	on type comparisons. (Although the result of a findMember on this member is used to check assignability.)

	Other changes: moved the call to the viewpoint-adaptation hook to NamedType#info rather than
	TypeRef/TermRef#underlying. This change ensures that a calls to both info and underlying return
	a viewpoint-adapted result.

VIEWPOINT ADAPTATION

	Successful adaptation of method results by using @mutabilityOf(this). See polymorphic_mut test.

	Type comparer needed to be augmented to check TypeRefs that refer to the mutability member
	 of another type. It is possible that the mutability member does not exist on the
	 referred-to type, so such TypeRefs are defaulted to mutable before comparing.

	Method receiver mutability is not yet considered. Taking receiver mutability into account
	during viewpoint adaptation should be easy enough, but something will have to be done about handling
	the mutability of ThisTypes.


Implemented mutability of types with ThisType and NoPrefix prefixes.
PROBLEM: There seems to be some infinite recursion when trying to find the type of an annotation itself.
SUCCESS: The problem was that I was performing viewpoint adaptation on module references,
which was causing an infinite loop when trying to resolve the type of dotty.readonly.
Fortunately, it is unnecessary to perform viewpoint adaptation on modules.
FAILURE: Having problems with ThisType class names not actually appearing in context trees.
E.g., the members of object P {...} are actually in the synthetic class P$ { ... }.
 Perhaps I can trace the ownership chain through symbols instead of contexts.
 It is possible that there will be uncompleted symbols in the ownership chain,
 but if there is a way to get annotations from uncompleted symbols, that should work.
FAILURE: Tried using the symbol's originalName instead of name. Doesn't work.
It is possible that viewpoint adaptation really doesn't need to do this.

However, the issue here is that a use of "this" inside a method should have the appropriate mutability,
and that mutability varies depending on what method the "this" is used within.
If a method is receiver-polymorphic in a class C, we need this to have the type:
 C { __MUTABILITY__ >: mutable <: readonly }
The question that remains here is: given an arbitrary this-type, how do we reliably
determine what its mutability should be? Is it safe to traverse the owner-symbol chain
starting from the current context owner? It seems to be safe...
The mutability of C.this can be read from the enclosing definition whose symbol is non-weak,
 and whose effective owner is C. If there is no such symbol, then we are inside the constructor
 of C, so C.this is mutable.

PROBLEM: Discovered it is possible for the current context owner to not be contained in
the class we want to get the ThisType of. Perhaps what we want to do is have the ThisType
mutability computation start with a symbol that we know is inside the correct class?
SOLVED: Ignored (returned mutable for) package/root classes and inside constructors.

NOTE: I'm not calling mutabilityOf when processing the @mutabilityOf(x) annotation.
It causes cyclic reference errors. For the @mutabilityOf(x) annotation, the mutability
is exactly x.__MUTABILITY__ without any attempt to simplify.

Failing tests:
	assignability
	receiver
	assignable_mutability_of
Changed defn.MutableAnnotType to MutableType in assignability check. The assignability test now passes.

NOTE ON TYPE BOUNDS: It seems that, in general, type bounds are only comparable to other type bounds
(or type aliases). Comparing a type bounds type to a non-type-bounds type does not seem to work.
The reason seems to be that type bounds (and class infos) are type types, whereas most other types
are term (value/reference) types.

The failing case in the receiver test is the following:
  class C {
    @mutabilityOf(c) def mc() = ???
  }
  val c: C @readonly = ???
  c.mc()  // ok
I'm getting the following error:
	./tests/dotmod/neg/receiver.scala:15: error: Incompatible receiver mutability in call to method mc:
	  Expected: dotty.mutable
	  Got: receiver.c.__MUTABILITY__
I should be getting receiver.c.__MUTABILITY__ for the declared receiver mutability, not mutable. Why?
This test is no longer up-to-date. The @mutabilityOf annotations are not currently supported for
 receiver types in DOTmod. Instead, we are using @polyread.
However, an error is still happening on the same line:
./tests/dotmod/neg/receiver.scala:15: error: Incompatible receiver mutability in call to method mp:
  Expected: C.this.__MUTABILITY__
  Got: receiver.c.__MUTABILITY__
It is possible that a this-substitution of some sort needs to happen here. Unlike appearances of
"this" in the method signature (which are substituted on application), appearances of "this" on the
method symbol itself are not automatically substituted.
SUCCESS: Correct behaviour observed on the receiver test.

Representation of this-polymorphism: The mutability of "this" is different depending on where
it is being viewed from.

This-Polymorphism:
	Thinking about changing @polyread on methods back to @mutabiltyOf(this).
	Reasoning:
	A "this" is never just a "this". A ThisType is implicitly understood to contain a mutability member,
	a member that is defined by annotations on an enclosing method. Where a method explicitly
	declares @mutable, appropriate ThisTypes ought to return a mutability of mutable, and likewise
	for @readonly. @mutabilityOf(this) is no exception--the mutability declared is this.__MUTABILITY__.
	Uses of "this" inside such methods are therefore understood to have the type "this @mutabilityOf(this)",
	 or "this.type{ __MUTABILITY__ += this.__MUTABILITY__ }". The selection of the __MUTABILITY__ member
	 of "this" is "this.__MUTABILITY__", so the definition is circular. While the circularity may seem odd,
	 what this definition captures is that the mutability of "this" is exactly itself.

	 What the foregoing means for type comparison is that ... well, trying to work out the defaults
	 inside the type comparer may be very difficult.
	 What the type comparer really should know is that the bounds on this.__MUTABILITY__ are
	 mutable .. readonly. Setting such bounds ensures that the type comparer knows that
	 mutable <: this.__MUTABILITY__ <: readonly.
	 So in such cases, the mutability of "this" is both bounded and aliased.
	 (For arbitrary type aliasing, the default bounds are assumed to be Nothing .. Any,
	 so bounds don't actually have to be set explicitly. But here, if we want to make sure
	 everything works OK with mutable .. readonly bounds, we have to make sure that these bounds
	 are either inserted literally, or otherwise that all parts of the system understand that
	 these bounds are there.)

	 One possibility for making sure all mutability defaults are computed correctly is to allow
	 findMember itself to be extended.
	 Another possibility is to literally retype This trees to be type refinements that define
	 the desired mutabilities.

Current test status:
	All DotMod tests currently passing except for assignable_mutability_of.
	The following method should generate an error, but doesn't:
    @polyread def n(): Any @mutabilityOf(this) = {
      x = x   // error: this has polymorphic mutability
      x  // ok
    }
Also generating cyclic reference errors on standard Dotty tests.
The cyclic reference error seems to be due to an attempt to access annotations on a symbol
while finding a receiver mutability. Standard annotation access attempts to complete the
symbol, which causes the cyclic reference. Instead of forcing symbol completion, I will
check whether the symbol is complete, and if not, reach into the completer to find the annotation
trees. (I had something like this before, but I disabled it because it didn't seem necessary, which
was because I could access symbol ownership chains without causing an error. But it seems that
ownership chains only need access to the symbol denotation, not the denotation info.)
PARTIAL SUCCESS.

One of the negative tests is triggering a DotMod assertion:
	testing ./tests/neg/i1050a.scala
	assertion failure for Tiark1.V(Tiark1.v) <:< ?{ brand: ? }, frozen = false

	java.lang.AssertionError: assertion failed: Owners of val <local Tiark1$> do not contain expected class V

It seems that one of my assumptions was incorrect. Namely, that the current context owner is never
outside the class that we are trying to get the this-type for.
Since this error is happening during viewpoint adaptation (triggered by a findMember),
perhaps the symbol to start the search with is the member being found--but this would be incorrect.
We still want to return the mutability of the this-type from the current point of view.
Perhaps the best thing to do here is just return mutable if the current context is outside of the
ThisType's class. I'm not entirely convinced this is the right thing to do, so I'm issuing a
"WEIRD WARNING" so I can see if it's happening anywhere unexpected (if it only happens on inputs
that have other errors, then it's probably OK to do this).

Assertion error on tests/neg/zoo.scala.
Happens during receiver-mutability checking at method application. A call to the method
symbol's effectiveOwner yields NoDenotation.
The method application in question here doesn't actually have a method symbol.
(The neg/zoo test attempts to define and call methods structurally, which is not supported by Dotty at this time.)
Issuing a "WEIRD WARNING" on this case also.

MatchError during pos/Iter2.scala:
The erasure phase finds the type: RefinedType(RefinedType(TypeRef(TermRef(NoPrefix,$1$),scala$Tuple3$$T2), __MUTABILITY__, TypeAlias(TypeRef(ThisType(TypeRef(NoPrefix,dotty)),mutable), 1)), __PREFIX_MUTABILITY__, TypeAlias(TypeRef(TermRef(NoPrefix,$1$),__MUTABILITY__), 1))
which it tries to interpret as an array of mutable type. I.e.: []dotty.mutable
It blows up because it doesn't expect more than one refinement. See:
	TypeErasure.apply (RefinedType case).
	TypeErasure.eraseArray (in particular, the first line: "val defn.ArrayOf(elemtp) = tp").
	Definitions.ArrayOf.unapply (in particular, the line: "case at: RefinedType if (at isRef ArrayType.symbol) && at.argInfos.length == 1 => Some(at.argInfos.head)").
Mutability refinements shouldn't be considered arrays.
The quickest solution is to disable phases starting at erasure. Can't do codegen, but at least lets me get on with other things.
The next easiest solution to this issue is to remove mutability refinements before the erasure phase (as with Rytz' work).

Errors found on dotty compiler test:
	./src/dotty/./tools/dotc/core/Symbols.scala:562: error: illegal cyclic reference: alias ErrorSymbol.this.underlying.ThisName of type ThisName refers back to the type itself
	    type ThisName = underlying.ThisName
	         ^
	./src/dotty/./tools/dotc/transform/Pickler.scala:48: error: missing arguments for method addrOfTree in class TreeBuffer
	follow this method with `_' if you want to treat it as a partially applied function
	      pickler.addrOfTree = treePkl.buf.addrOfTree
	                                       ^
	./src/dotty/./tools/dotc/transform/Pickler.scala:49: error: missing arguments for method addrOfSym in class TreePickler
	follow this method with `_' if you want to treat it as a partially applied function
	      pickler.addrOfSym = treePkl.addrOfSym
	                                  ^
The first of these errors doesn't seem to interact with DotMod code at all. I'm going to ignore it for now.
Probably best to ignore tests other than standard pos & neg for now.

Another error:
./tests/pos/t1123.scala:8: error: non-private method f refers to private object extraListener
 in its type signature => AnyRef{__MUTABILITY__ =+ dotty.mutable; __PREFIX_MUTABILITY__ =+ Editor.this.extraListener.__MUTABILITY__}
    def f = extraListener.h
        ^
Temporary fix: Set __PREFIX_MUTABILITY__ to be either mutable or readonly (no path-dependent stuff).
Although it's probably not a complete solution.
Update: after adding better mutability defaulting (below), t1123 now passes. It passes because the mutability of path
Editor.this.extraListener now resolves to the mutability of Editor.this, which resolves to dotty.mutable.
However, t2435 (below) still fails.

Another error:
./tests/pos/t2435.scala:10: error: illegal cyclic reference: alias FConstant.this.tail.T of type T refers back to the type itself
    type T = tail.T
         ^
Probably from the same basic problem as the previous error.
Update: Probably not the same basic problem: still fails, but t1123 passes.

Maybe I've got to:
- add mutability members to all types where they're valid (during tree adaptation)
- look up mutabilities with findMember during viewpoint adaptation (rather than make TypeRefs)

What I actually did:
- Add checks in the type comparer where the mutability member is not defined:
  - if we're comparing a TypeRef with ThisType prefix, don't default to any other mutability.
  - if tp2 is the readonly type, or tp1 is the mutable type, pass the subtype with no further checks.
SUCCESS: All current DotMod tests pass.

Up next:
- test mutability of type bounds (abstract type members)
- ExprType annotations / viewpoint adaptation / receiver checking
- RefChecks?

Bugfix: Test pos/Map was failing because abstract type bounds now have an upper bound of readonly,
but like "==" were getting a mutable receiver by default. The fix is to whitelist certain method names.
Currently, all method names I find in Any and most in AnyRef are defaulted to polymorphic receiver mutabilities.
All methods in class AnyVal are also defaulted this way. AnyVal is a strange case because it's not a
reference type, but Scala allows it to be inherited.


DEFAULTING OF METHOD RESULTS:
	The only method that seems like it should be viewpoint-adapted by default is asInstanceOf[T].
	But even then, the result should be adapted only if the type T does not have a declared mutability.
	If T does have a declared mutability, can asInstanceOf[T] be used to force a the result to have
	a particular mutability?
	Actually, asInstanceOf is an ExprType, so viewpoint adaptation should already occur where other
	viewpoint adaptation is being done. However, the result of asInstanceOf is:
		PolyType(List(T0), List(TypeBounds(TypeRef(ThisType(TypeRef(NoPrefix,scala)),Nothing), TypeRef(ThisType(TypeRef(NoPrefix,scala)),Any))), PolyParam(T0))
	How do I adapt this kind of result?
		What we've got here is a polymorphic expression, which is a PolyType with an ExprType result.
	SUCCESS: asInstanceOf is now a safe method to call. Now, what about matching?

TYPE ERASURE AND MUTABILITY:
	What happens if I only remove __PREFIX_MUTABILITY__ members, and leave __MUTABILITY__members as they are?
	Do I get runtime mutability information, or more problems?


Problem: Defaulting parameterless methods to @polyread seems to be causing some errors,e.g.:
	./tests/pos/t2435.scala:9: error: type mismatch:
	 found   : String{__MUTABILITY__ =+ FConstant.this.__MUTABILITY__; __PREFIX_MUTABILITY__ =+ FConstant.this.__MUTABILITY__}(FConstant.this.constant)
	 required: String
	  case class FConstant[E <: FChain](constant:String, tail:E) extends FChain {
Perhaps there's a parameterless method call buried in the desugaring of the case class?
(There was a similar-looking error in pos/Map which I fixed by forcing a method receiver to be mutable.)
New information:
	When I disable the receiver defaulting for parameterless methods, I get a different error at about the same place:
	java.lang.AssertionError: assertion failed: error at ./tests/pos/t2435.scala:10
	type mismatch:
	 found   : String{__MUTABILITY__ =+ FConstant.this.__MUTABILITY__; __PREFIX_MUTABILITY__ =+ FConstant.this.__MUTABILITY__}(FConstant.this.constant)
	 required: Any
	tree = Ident(constant)
		at scala.Predef$.assert(Predef.scala:165)
		at dotty.tools.dotc.transform.TreeChecker$Checker.adapt(TreeChecker.scala:430)
		at dotty.tools.dotc.typer.ProtoTypes$FunProto.typedArg(ProtoTypes.scala:205)
		...
This looks like a bounds-checking error, where a non-mutable reference is not compatible with Any.
I did a search for all uses of defn.AnyType in dotc outside of dotmod, and got 30 results.
Possibly, I will need to make Any a readonly thing. Not sure what implications this has for asInstanceOf and matching,
but Any doesn't have any non-mutable-receiver methods, so at least method calls on Any in existing code should be OK.

New information:
Changed Any to be readonly in the type comparer, and the t2435 error went away.
 But now there is a remarkably similar error in Iter2:
	java.lang.AssertionError: assertion failed: error at ./tests/pos/Iter2.scala:206
	type mismatch:
	 found   : Int{__MUTABILITY__ =+ ArrayIterator.this.__MUTABILITY__; __PREFIX_MUTABILITY__ =+ ArrayIterator.this.__MUTABILITY__}(ArrayIterator.this.len)
	 required: Int
	tree = Ident(len)
		at scala.Predef$.assert(Predef.scala:165)
		at dotty.tools.dotc.transform.TreeChecker$Checker.adapt(TreeChecker.scala:430)
		...
This time, the required type is Int. Again, it involves a case class. The specific method causing the error is synthetic:
  override def hashCode(): Int = {
    var acc: Int = -889275714
    acc = scala.runtime.Statics$#mix(acc, scala.runtime.Statics$#anyHash(ArrayIterator.this.elems))
    acc = scala.runtime.Statics$#mix(acc, ArrayIterator.this.len)
    scala.runtime.Statics$#finalizeHash(acc, 2)
  }
The type mismatch is at the call to Statics$#mix(acc, ArrayIterator.this.len).
hashCode is considered to have a polymorphic receiver mutability, but the parameters to mix are mutable.
Perhaps the best solution here is to stop defaulting receiver mutabilities by name.
I could default these mutabilities by class (e.g., only for methods of Any/AnyRef/AnyVal/Object),
which would require overriding methods to be explicit about their receiver mutabilities.
Perhaps a different, more practical, solution would be to simply not check the receiver mutabilities
for these methods. Such a solution would allow mutating overrides of these methods, which means that
overriders would have to be careful not to introduce mutations.

Attempted to make @mutabilityOf(this) the default receiver and result mutability for parameterless methods.
However, this seems to break a lot of stuff (particularly in collections code--see pos/Iter2 test).

Perhaps in the interests of practicality, I should
1. leave the default receiver mutability for all methods as @mutable.
2. continue to viewpoint-adapt parameterless methods by default.
	Such methods can only be called on mutable receivers, unless otherwise annotated.
	Such methods can be safely overridden by vals (but not the reverse).
    (Viewpoint adaptation of an explicitly receiver-polymorphic result-mutability has no effect
    on the adapted result. The receiver this-type is substituted by the prefix type
    when the method is applied; the subsequent union of prefix mutability with result mutability
    produces no additional change in mutability.)
4. introduce a @fresh annotation for method definitions that indicates that:
	- The result of the method is not viewpoint-adapted.
	- The receiver and all other closed-over variables are non-mutable.

PROBLEM: When a method is called like an expression, a call to realApply is not generated. E.g.:

	def em(): C = ???
	def fm(): C = em()  // generates a call to realApply
	def gm(): C = em    // does not generate a call to realApply

Probably, the solution here is to check receiver mutabilities and adapt result mutabilities
at the time the method is selected (rather than at the time the method is applied).
The framing of this approach is: A method selection is valid only if receiver types are compatible.
(Rather than: A method application is valid only if ...)
This would ensure that receivers are checked and the correct result type is observed even if realApply is not called.

Update: It seems that the receiver-mutability check needs to happen after a tree is typed, but before
default tree adaptation logic occurs. The default adaptation logic may silently resolve parameterless-method
selections to their results, making it impossible to reliably check their receivers.

PROBLEM: Viewpoint adaptation is not correctly resolving the following:
		val g:D = dm.asInstanceOf[D @readonly]
	where dm is mutable. It does not produce an error here, but it should.
Upon closer examination, what's happening is that the selection of "asInstanceOf" sees an
underlying PolyType with an uninstantiated type parameter. Since the uninstantiated result
does not report having a mutability member (uninstantiated PolyParams return their origins?),
this points to a larger problem that could affect any viewpoint-adapted polymorphic method.
Interpolation happens in Typer#apply.
Perhaps the solution here is to extend adaptInterpolated rather than adapt, and do the
viewpoint adaptation there.

Update: The problem actually seems to be that the viewpoint adaptation code was refining
the uninstantiated PolyParam result with __MUTABILITY__ = mutable. When the PolyParam was
instantiated, the outermost mutable was still present, causing the type to be interpreted
as mutable regardless of the underlying type. The current implementation now refines the
mutability member only if the adapted mutability is different from the underlying.

All dotmod tests (including some new ones) now pass again.

Error: No errors being reported for tests/neg/i1050a.
Problem with refchecks extension maybe?
Fixed: As it turns out, the refchecks phase wasn't running. Now it is, and the test works correctly.

All positive Dotty tests now pass except for these three, which all seem to share a specific
kind of cyclic reference error:
    pos_t758()
    pos_t2698()
    pos_t2435()
Notably: the neg/i1240a test requires the erasure phase to be executing.
The following Dotty tests are now passing:
	pos_all  (with the exception of "illegal cyclic reference"-generating tests)
	neg_all
	new_all
	repl_all
	pickle_*
	compileStdLib
	compileMixed
	compileIndexedSeq
	dotc_ast
	dotc_config
	dotc_parsing
	dotc_printing
	dotc_reporting
	dotc_typer
	dotc_util
	tools_io
	java_all
	tasty_new_all
	tasty_runtime
	tasty_runtime_vc
	tasty_tools
	tasty_backend_jvm  (pre-existing caveat noted in tests file: "issue with ./src/dotty/tools/backend/jvm/DottyBackendInterface.scala")
	tasty_backend_sjs
	tasty_dotc
	tasty_dotc_ast
	tasty_dotc_config
	tasty_classfile
	tasty_tasty
	tasty_unpickleScala2
	tasty_dotc_parsing  (pre-existing caveat noted in tests file: "issue with ./src/dotty/tools/dotc/parsing/Parsers.scala")
	tasty_dotc_printing
	tasty_dotc_repl
	tasty_dotc_rewrite
	tasty_dotc_transform  (pre-existing caveat noted in tests file: "issues with LazyVals.scala, PatternMatcher.scala")
	tasty_typer  (pre-existing caveat noted in tests file: "issue with ./src/dotty/tools/dotc/typer/Namer.scala")
	tasty_dotc_util
	tasty_tools_io
	tasty_tests
The following fail:
	dotc_core, with the error (same for dotc_core_nocheck, tasty_core):
		./src/dotty/tools/dotc/core/Symbols.scala:562: error: illegal cyclic reference: alias ErrorSymbol.this.underlying.ThisName of type ThisName refers back to the type itself
		    type ThisName = underlying.ThisName
		         ^
	dotc_transform, with the error (in transform/PostTyper.scala):
		java.lang.ClassCastException: dotty.tools.dotc.core.Types$TermRefWithFixedSym cannot be cast to dotty.tools.dotc.core.Types$ThisType
			at dotty.tools.dotc.DotMod$.mutabilityOf(DotMod.scala:294)
			at dotty.tools.dotc.DotMod$.viewpointAdapt(DotMod.scala:413)
			at dotty.tools.dotc.DotMod$DotModTypeOpHooks.denotInfoAsSeenFrom(DotMod.scala:464)
			...
	tasty_dotty, with the error:
		java.lang.ClassCastException: dotty.tools.dotc.core.Types$RealTypeBounds cannot be cast to dotty.tools.dotc.core.Types$TypeAlias
			at dotty.tools.dotc.DotMod$.substThisMutability(DotMod.scala:398)
			at dotty.tools.dotc.DotMod$.viewpointAdapt(DotMod.scala:412)
			at dotty.tools.dotc.DotMod$DotModTypeOpHooks.denotInfoAsSeenFrom(DotMod.scala:464)
			...
<DISCUSSION: MUT_BOUNDS>
The last error is due to an attempt to compile the src/dotty/mutableOf file. It seems that none of the other
tests actually catch files in the top-level src/dotty directory. The issue is the declaration
	val ref: { type __MUTABILITY__ <: readonly }
which is a type bounds rather than a type alias.
What this really is is a way to express covariance in code. Since the internal representation of mutability
is a covariant type alias (see the earlier discussions of the problems of using type bounds internally to represent
mutability), it is probably correct to take the upper bound of the mutability member as the mutability.
SUCCESS: test tasty_dotty passes.

<DISCUSSION: SUPER_THIS_MUT>
For the dotc_transform error, the error shows up when trying to compile the following line in PostTyper.scala:
	superAcc.transformSelect(super.transform(tree), targs)
The supertype's this-type is somehow a TermRef(NoPrefix,$this) rather than an actual ThisType.
Is this a problem? Not necessarily... I can easily take the mutability of a TermRef as well as a ThisType.
There is, however, a question in my head about whether it is appropriate to do this.
Under what circumstances is a val $this created in lieu of a ThisType?
In any case, super and this refer to the same object. Regardless of what the underlying "this"-type is,
its mutability should be the same as the mutability of super.
SUCCESS: test dotc_transform passes.

DOTTY BUG discovered: Running some positive tests twice generates a stale symbol error during the erasure phase,
in an attempt to find the outer-accessor parameter of the class MapCanBuildFrom.
This error was not discovered earlier because the "twice" option is not enabled on batch tests (e.g., pos_all).
Notably, the following tests are known to fail:
	dotc/transform/PostTyper
	pos/Map
The output for pos/Map with "twice" is:
	dotty.tools.dotc.core.Denotations$StaleSymbol: stale symbol; method scala$collection$generic$GenMapFactory$MapCanBuildFrom$$$outer#22048 in class MapCanBuildFrom, defined in Period(20..34, run = 2), is referred to in run Period(34..34, run = 3)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.staleSymbolError(Denotations.scala:830)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.bringForward(Denotations.scala:646)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.currentIfExists(Denotations.scala:675)
		...
This is possibly a Dotty bug.
It has been replicated on the Dotty master branch.

New feature: Receiver mutability checking. (During RefChecks phase.)
Note: It looks like it may be possible to run the custom RefChecks phase as a miniphase instead of a standalone phase.

Problem with ThisType comparisons: When running the receiver_override test, the following error is improperly triggered:
	./tests/dotmod/neg/receiver_override.scala:16: error: Cannot override method n due to receiver mutability.
	   Overridden mutability: C.this.__MUTABILITY__
	   Overriding mutability: E.this.__MUTABILITY__
	    @polyread override def n(): Unit = ???  // ok
Probably, the type comparer does not make use of the fact that E is a subclass of C.
SOLUTION: There needed to be a substitution of E.this for C.this.
(See discussion of declared receiver types and substThis above.)

Information:
As it turns out, dotty does not let you override vals with defs.
The following code in RefChecks prevents it:
	if (other.isStable && !member.isStable) // (1.4)
		overrideError("needs to be a stable, immutable value")
The basic provision in this check is this:
	Unstable things cannot override stable things.
	(Purity may be similar: Impure things cannot override pure things.)
I suppose this provision allows the compiler to know that a field read is always a
field read, and not a method call.

<DISCUSSION: OVERRIDE_VAL_DEF>
On overriding: An adjustment needs to be done when checking receiver mutabilities during
overriding of a method/expr with a field. Specifically, a field's receiver is polyread (or mutabilityOf(this)),
which allows a value def to override a parameterless method def:
    @polyread def u: Any @mutabilityOf(this)
    ...
    override val u: Any   // should be OK
The result type comparison does not need adjustment because the result of val u is interpreted
as @mutable, which is a subtype of @mutabilityOf(this). Furthermore, vals can override vals without
problem (their receivers and result types evaluate to @mutable, which is technically incorrect,
but the point is that they are found to be compatible).
The opposite case, where a def overrides a val, is not supported here.


POLYMORPHISM, PART 2

Consider the following generic collection-like class:

  class C[T](elem: T) {
    @mutabilityOf[T] def get: T = elem
  }

The @mutabilityOf[T] here means that the receiver (this) has the mutability T#__MUTABILITY__.
(To avoid a name clash, the @mutabilityOf annotation above has been renamed @mutabilityOfRef.)

PROBLEM: Stack overflow.
	Overflow occurs when attempting to type the tree Ident(T) inside the @mutabilityOf annotation.
Cause:
	(in DotModTyper) adaptInterpolated is calling preChecks which is calling mutabilityOfThis
	on C.this in preparation for calling checkedReceiver.
	mutabilityOfThis is calling declaredReceiverType, which tries to type method annotations,
	causing a circular reference chain.
Diagnosis:
	checkedReceiver really only cares about selections of method symbols.
	So why are we finding prefix mutability for selections of non-methods (e.g., selection of named types,
	which we are doing here)?
SOLVED:
	Before asking for the mutability of anything, check whether the tree symbol really should have its
	receiver checked.

PROBLEM:
	The type argument T in @mutabilityOf[T] is not showing up in the arguments list.
CANDIDATE SOLUTION:
	Added a typedArguments method to the Annotation class that returns trees of type args.
NEXT PROBLEM:
	The argument T, when typed, triggers the following assertion in Typer#typedTypeTree:
		assert(isFullyDefined(pt, ForceDegree.none))
	According to the isFullyDefined documentation, false is returned if pt is a wildcard or uninstantiated type.
	Is there a way to get the type of the type argument without trying to type it directly?
SOLUTION:
	The type of @mutabilityOf[T] actually resolves to a RefinedType after typing.
	The refinedInfo of this type is a TypeAlias to the type we want.

Possibly need to rewrite the mutabilityOf method.

<DISCUSSION: POLYMORPHIC_2>
PROBLEM:
	Type comparer error:
	N#__MUTABILITY__ | T#__MUTABILITY__ is resolving to just T#__MUTABILITY__.
	Appears to involve defaulting these types to mutable in the type comparer.
SOLUTION:
	When finding mutability, don't use findMember right away.
	Instead, do a widenDealias, then see if the result is a TypeRef to an abstract/uninstantiated type member.
	If so, then make the mutability T#__MUTABILITY__ (where T is the uninstantiated type member).

	Also needed to add a special case to the type comparer.
	The case is similar to what had to be done for this-mutability.

	Also needed to loosen the refinement condition in viewpoint adaptation from
		if (finalMut ne tpMut)
	to
		if (finalMut ne defn.MutableAnnotType)
	Although logically it makes sense that we only need to change the mutability if it is different from
	what's already there, right now the type comparer doesn't always call mutabilityOf,
	so it doesn't always know that a type T should be understood to have mutability T#__MUTABILITY__.
FAILURE:
	Loosening the refinement condition in viewpoint adaptation causes Dotty tests to fail, notably
	dotc/core/Symbols, which reports 8 errors (of various types) instead of the previous 1.
NEW SOLUTION:
	Add a condition in the type comparer that any type T is assumed to have mutability T#__MUTABILITY__,
	unless overridden by another mutability. What this means practically is:
	In the type comparer, when tp2 is a mutability refinement with refinedInfo T#__MUTABILITY__, and tp1 is T,
	then the mutability check passes.
	Also, when tp1 is a mutability refinement with refinedInfo T#__MUTABILITY__, and tp2 is T,
    then the mutability check passes.

    Alternatively, if tp1 is a mutability refinement, compare its refinedInfo with mutabilityOf(tp2).
    Previously, the mutability of tp2 was approximated by a simple findMember with default to @mutable.
    Similarly, if tp2 is a mutability refinement, compare its refinedInfo with mutabilityOf(tp1).
    However, the type comparer has a case for special-casing Any to readonly when checking the tp2 refinement.
    Perhaps this special case should go into mutabilityOf instead?

SUCCESS: DotMod neg tests all pass again.

FAILURE in dotc/transform/PostTyper test:
	./src/dotty/tools/dotc/transform/PostTyper.scala:123: error: Incompatible receiver mutability in call to method tpe:
	  Expected: dotty.mutable
	  Got: T#__MUTABILITY__
	  private def fixSignature[T <: Tree](tree: T)(implicit ctx: Context): T = tree.tpe match {
	                                                                                ^
	./src/dotty/tools/dotc/transform/PostTyper.scala:125: error: Incompatible receiver mutability in call to method tpe:
	  Expected: dotty.mutable
	  Got: T#__MUTABILITY__
	      typr.println(i"fixing $tree with type ${tree.tpe.widen.toString} with sig ${tpe.signature} to ${tpe.widen.signature}")
	                                                   ^
	./src/dotty/tools/dotc/transform/PostTyper.scala:126: error: Incompatible receiver mutability in call to method withType:
	  Expected: dotty.mutable
	  Got: T#__MUTABILITY__
	      tree.withType(TermRef.withSig(tpe.prefix, tpe.name, tpe.widen.signature)).asInstanceOf[T]
	           ^
	./src/dotty/tools/dotc/transform/PostTyper.scala:126: error: value asInstanceOf does not take type parameters
	      tree.withType(TermRef.withSig(tpe.prefix, tpe.name, tpe.widen.signature)).asInstanceOf[T]
	                                                                                            ^
Perhaps what I've got to do here is expand T#__MUTABILITY__ to its upper-bound mutability (which should be mutable here).
We'll also see if that does anything to the fourth error above.
FIXED.

<DISCUSSION: ITER2_ASINSTANCEOF>
New errors in pos/Iter2:
	./tests/pos/Iter2.scala:143: error: type mismatch:
	 found   : AnyRef{__MUTABILITY__ =+ SA#__MUTABILITY__; __PREFIX_MUTABILITY__ =+ SA#__MUTABILITY__}
	 required: AnyRef
	        elems(i) = it.next.asInstanceOf[AnyRef]
	                                       ^
	./tests/pos/Iter2.scala:210: error: type mismatch:
	 found   : AnyRef{__MUTABILITY__ =+ dotty.readonly; __PREFIX_MUTABILITY__ =+ dotty.readonly}
	 required: AnyRef
	    private def widen(x: Any): AnyRef = x.asInstanceOf[AnyRef]
	                                                      ^
These errors have to do with the semantics of asInstanceOf.
I cannot determine whether these should or should not be errors -- more work on collection mutabilities is needed.

PARTIAL SUCCESS: Passes at least:
	all_dotmod_neg
	dotmod_failed_tests
	neg_all
Fails at least:
	tests/pos/annot-bootstrap

Going to finish work on collection mutabilities before trying to fix these errors.

DIAGNOSTIC on collection test failure:

The following generates an error as expected:
  class C[T] {
    @mutabilityOf[T] def get(): T = ???
  }
  val c: C[AnyRef@readonly] = ???
  val d: AnyRef = c.get()   // error

The following does not generate the error:
  class C[T] {
    @mutabilityOf[T] def get: T = ???
  }
  val c: C[AnyRef@readonly] = ???
  val d: AnyRef = c.get   // NO ERROR GENERATED

Printing key subtype comparisons (specifically, where either type matches RefinedType(_, MutabilityMemberName, _) or TypeRef(_, _);
	the "comparing" lines are entries into custom subtyping logic, "supercall" entries are exits to default logic):
The former has the following output immediately prior to the error:
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	supercall AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	./tests/dotmod/neg/collections/temp.scala:10: error: type mismatch:
	 found   : AnyRef{__MUTABILITY__ =+ dotty.readonly}
	 required: AnyRef
	  val d: AnyRef = c.get()
	                       ^
The latter has the following different output starting at the same position:
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to ?...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to AnyRef...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	supercall => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to AnyRef.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	supercall => AnyRef{__MUTABILITY__ =+ dotty.readonly}(temp.c.get) to Object.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing Object to Object...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing <empty>.type to temp$...
	supercall <empty>.type to temp$.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing T to Any...
	comparing Nothing to T...
	supercall Nothing to T.
	comparing Nothing to Nothing...
	comparing T to Any...
	comparing Nothing to T...
	supercall Nothing to T.
	comparing Nothing to Nothing...
	comparing T to Any...
	comparing Nothing to T...
	supercall Nothing to T.
	comparing Nothing to Nothing...
	comparing temp.C[T] to dotty.mutabilityOf...
	supercall temp.C[T] to dotty.mutabilityOf.
	comparing temp.type to dotty.mutabilityOf...
	supercall temp.type to dotty.mutabilityOf.
	comparing <empty>.type to dotty.mutabilityOf...
	supercall <empty>.type to dotty.mutabilityOf.
	comparing <root>.type to dotty.mutabilityOf...
	supercall <root>.type to dotty.mutabilityOf.
	comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to Any...
	comparing Nothing to AnyRef{__MUTABILITY__ =+ dotty.readonly}...
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing Nothing to AnyRef...
	supercall Nothing to AnyRef.
	comparing Nothing to Object...
	supercall Nothing to Object.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing temp.type to temp.C...
	supercall temp.type to temp.C.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to T#__MUTABILITY__...
	comparing Any to Nothing...
	supercall Any to Nothing.
	supercall dotty.mutable to dotty.mutable.
	comparing T#__MUTABILITY__ to dotty.mutable...
	comparing Any to Any...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.
	comparing dotty.mutable to dotty.readonly...
	supercall dotty.mutable to dotty.readonly.
	comparing dotty.readonly to dotty.readonly...
	comparing dotty.readonly to dotty.mutable...
	supercall dotty.readonly to dotty.mutable.

	The first question here is why we're not invoking more custom logic on "comparing AnyRef{__MUTABILITY__ =+ dotty.readonly} to AnyRef."
POTENTIAL SOLUTION:
	It seems that a widen/dealias operation needs to be applied to both types in the comparision before
	attempting to trigger custom logic.
	Let's see if tests still pass.
PROBLEM:
	Broke compatibility when comparing mutabilities with type bounds (e.g., {__MUTABILITY__ <: dotty.readonly}).
POSSIBLY FIXED:
	Stopped caring about the lower bound of any mutability member info. Now using the upper bound of any member info as the correct mutability.
		(This should work since all mutability members currently in use are either covariant aliases, or otherwise upper-bound-only (e.g., <: readonly).
	Was also accidentally failing to check mutability members when both tp1 and tp2 contained them.
POSSIBLY FIXED WITH INCREASED CERTAINTY:
	collection_mut test now passes for the first time!
	all_dotmod_neg passes.
	dotmod_failed_tests passes.

CHANGED: mutabilityOf to always give a type alias or type bounds.
Update: Doesn't seem to really make any difference -- changing mutabilityOf back to returning non-bounds types.

<DISCUSSION: EXPR-ADAPTATION>
Why are we viewpoint-adapting ExprTypes? Since we're checking receiver types for ExprTypes, viewpoint-adaptation seems unnecessary.
The key issue to consider here is compatibility of field declarations and getters. See, e.g., from the simple_viewpoint test:
  class C {
    val x: AnyRef = ???
    @polyread def y = x
  }
The field x is automatically @polyread. The getter y needs to be annotated (unless we set a default).
For a discussion of overriding, see <DISCUSSION: OVERRIDE_VAL_DEF>.

<DISCUSSION: ASINSTANCEOF>
Since we're no longer doing viewpoint adaptation on ExprTypes (or PolyTypes), asInstanceOf is also no longer
viewpoint adapted. This change means that asInstanceOf remains useful for making exceptions to the default
RI typing regime, although (like case matching) it opens up the possibility of unintentional RI violations.
(See related <DISCUSSION: ITER2_ASINSTANCEOF>.)

<DISCUSSION: WIDEN-DEALIAS>
Pursuant to PROBLEM above: In the collection_mut test, we have:
  class C[T](elem: T) {
    val e: T = elem
    @mutabilityOf[T] def get: T = elem
    @mutabilityOf[T] def get2(): T = elem
  }
  class D
  val cdr: C[D @readonly] = ???
  val dr0: D = cdr.e       // Should give an error, but doesn't
  val dr1: D = cdr.get     // Should give an error, but doesn't
  val dr2: D = cdr.get2()  // error: type mismatch
The issue here seems to be that there is no automatic substitution/dealiasing of cdr.T (which should yield D @readonly)
during widening or viewpoint adaptation. (We do, however, have a corresponding substThis that does happen
during viewpoint adaptation [discussed earlier]).
The currently-implemented solution is to do a widenDealias on tp1 when checking for mutability member refinements
in the type comparer (where previously there was only a widen).
Interestingly, it seems that widening or dealiasing tp2 causes problems, but widening and dealiasing are necessary on tp1.

Known-passing tests:
	all_dotmod_neg
	dotmod_collection_mut
	dotmod_failed_tests (except for cyclic reference tests)
	pos/Iter2 now passes due to no longer viewpoint-adapting asInstanceOf
	neg_all

<DISCUSSION:ANNOTATION-TYPER-CONTEXT>
PROBLEM with annotation typing:
Consider:
  class C {
    class Extractor {
      @mutabilityOfRef(C.this) def get = ???
    }
  }
  val cr: C @readonly = ???
  val x: AnyRef = (new cr.Extractor).get
When typing the last line, we look up the annotation on Extractor#get, which contains the argument C.this.
Currently, the argument C.this is getting typed at the call to get, which means that dotty searches
for class C starting at the context that is current at the call to get. What we really want is to
type C.this at the original/creation context of method get.

dotmod_extractor test now triggers the following exception:
	dotty.tools.dotc.core.Denotations$NotDefinedHere: demanding denotation of class Extractor at phase patternMatcher(19) outside defined interval: defined periods are Period(21..24, run = 2)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.currentNoDefinedHere(Denotations.scala:753)
		at dotty.tools.dotc.core.Denotations$SingleDenotation.current(Denotations.scala:746)
		at dotty.tools.dotc.core.Types$NamedType.computeDenot(Types.scala:1426)
		at dotty.tools.dotc.core.Types$NamedType.denotAt(Types.scala:1408)
		at dotty.tools.dotc.core.Types$NamedType.denot(Types.scala:1396)
		at dotty.tools.dotc.core.Types$Type.go$1(Types.scala:420)
		at dotty.tools.dotc.core.Types$Type.findMember(Types.scala:568)
		at dotty.tools.dotc.core.Types$Type.memberExcluding(Types.scala:405)
		at dotty.tools.dotc.core.Types$Type$$anonfun$member$1.apply(Types.scala:389)
		at dotty.tools.dotc.core.Types$Type$$anonfun$member$1.apply(Types.scala:389)
		at dotty.tools.dotc.util.Stats$.track(Stats.scala:36)
		at dotty.tools.dotc.core.Types$Type.member(Types.scala:388)
		at dotty.tools.dotc.DotMod$.substThisMutability(DotMod.scala:466)
		at dotty.tools.dotc.DotMod$DotModTypeOpHooks.denotInfoAsSeenFrom(DotMod.scala:514)
		...
Can this problem be fixed by moving substThisMutability elsewhere (e.g., inside viewpoint adaptation?)
SOLUTION:
	This problem is not really with substThisMutability at all.
	The problem is that when we try to type the annotation, we were using the current context's typer,
	not the typer/context that was in effect at the symbol where the annotation is used.
	So I added a field originalOuterContext to the Completer class, which allows me to type the
	annotations in the same context that defines the symbol.

	But what happens if the annotation uses a type or term parameter of the method itself?
	This does not seem to be a problem. Two examples of such dependence:
	    class Extractor {
          @mutabilityOf[T] def c[T](n: T) = ???
          @mutabilityOfRef(n) def c[T](n: T) = ???
        }
	The first (using @mutabilityOf[T]) triggers a "T not found" error.
	The error seems reasonable because the annotation is not really part of the method signature,
	 so it isn't clear to me whether it even makes sense for T to mean c's type parameter here.
	 (Would we be saying that an application of c would cause a substitution of T in
	 the annotation? That would make sense if we used @mutabilityOf[T] as a type annotation,
	 but as a symbol annotation it doesn't make sense.)
	The second compiles without problems.
TESTS:
	all_dotmod_neg passes.
	dotmod_failed_tests passes (again, except for cyclic-reference tests).
	pos_all passes.
	neg_all passes.
		Also turned all WEIRD WARNINGs back on. The following warnings exist:

		testing ./tests/pos/class-dependent-extension-method.scala
		WEIRD WARNING: Mutability of C.this is being requested from outside of class C. Assuming @mutable.

		testing ./tests/pos/valueclasses
		WEIRD WARNING: Mutability of ValueClass.this is being requested from outside of class ValueClass. Assuming @mutable.

		testing ./tests/neg/i1050a.scala
		WEIRD WARNING: Mutability of V.this is being requested from outside of class V. Assuming @mutable.

		testing ./tests/neg/i1050c.scala
		WEIRD WARNING: Mutability of V.this is being requested from outside of class V. Assuming @mutable.

		This is a notable drop in frequency of such warnings.
